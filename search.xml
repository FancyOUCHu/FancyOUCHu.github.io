<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Zotero 系列教程</title>
      <link href="/2023/12/08/Useful%20tools/Zotero%20%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
      <url>/2023/12/08/Useful%20tools/Zotero%20%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="zotero与markdown"><a class="markdownIt-Anchor" href="#zotero与markdown"></a> Zotero与markdown</h2><ol><li>markdown中如何利用Zotero引用参考文献。<a href="https://blog.csdn.net/subtitle_/article/details/128995875">参考</a></li></ol><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 科研工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VSCode 系列教程</title>
      <link href="/2023/12/08/Useful%20tools/VSCode%20%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
      <url>/2023/12/08/Useful%20tools/VSCode%20%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="vscode配置cc"><a class="markdownIt-Anchor" href="#vscode配置cc"></a> VScode配置C/C++</h3><span id="more"></span><h4 id="初步配置"><a class="markdownIt-Anchor" href="#初步配置"></a> 初步配置</h4><ol><li>由于C语言是编译型语言，而vscode仅仅是一个代码编辑器，故需要先配置编译器，这里我选择mingw-w64的<a href="https://sourceforge.net/projects/mingw-w64/files/"><strong>gcc编译器</strong></a>。注意下载后需要将&quot;…\mingw64\bin&quot;放到环境变量（不放心的话系统和用户环境变量都添加上）。</li><li>然后在vscode上下载扩展插件(C/C++),这里要注意，尽量安装版本较老的，否则不会自动生成launch.json文件。如果实在没法自动生成，可自己配置，参考<a href="https://blog.csdn.net/m0_63702526/article/details/130136859">VSCode配置C/C++</a>等多篇文章.</li><li>配置好之后，可以运行C/C++源文件了，但发现：<strong>终端窗口在程序一运行完就立即消失了</strong>，于是上网查阅了各种办法，选择了两种运行方式：（具体见配置文件 <code>launch.json</code> 和<code>tasks.json</code>。当然，两者都是gcc编译的。）<ol><li>在外终端（C:\WINDOWS\system32\cmd.exe）运行可执行文件(.exe)。</li><li>在内终端(D:\Computer Softwares\Visual studio code\Codes..)(即项目所在地址，相当于直接git bash here) 运行可执行文件(.exe)。</li></ol></li><li>但是很快就发现一个问题，外终端运行时打印汉字会乱码，于是在<code>tasks.json</code>文件中增加<code>&quot;-fexec-charset=GBK&quot;</code>，但很快就发现，内终端运行时就乱码了。于是查阅<a href="https://blog.csdn.net/weixin_43439450/article/details/118331694"><strong>网上一些资料</strong></a>，进行如下操作即可实现内外终端均不会乱码。<ol><li>将cmd的编码（解码）方式由默认的<code>gbk</code>换成<code>utf-8</code>,具体参考<a href="https://blog.csdn.net/qq_43768851/article/details/123501124"><strong>如何更改cmd的编/解码格式</strong></a>.</li><li>将gcc的编/解码方式也换成<code>utf-8</code>,(这也是gcc默认的)，在<code>tasks.json</code>文件中增加<code>&quot;-finput-charset=UTF-8&quot;</code>,删掉原来的<code>&quot;-fexec-charset=GBK&quot;</code>.</li></ol></li><li>至此，就完成了VScode对C/C++的配置！<br>注意：<ol><li><strong>项目所在地址应为英文路径</strong>，否则编译器会报错。</li><li>配置好的<code>c_cpp_properties.json</code>、<code>lanuch.json</code>和<code>task.json</code>见<a href="https://pan.baidu.com/s/1PKbGVBoxTYaMnY56qU3W2w?pwd=8jda">链接</a>,提取码:8jda.将这三个文件放入<code>.vscode</code>文件夹下，即可完美运行<strong>C源文件</strong>，对于<strong>C++源文件</strong>目前还未测试。</li><li>对于多个C文件同时运行是不支持的，可能因为<strong>编译生成的程序名称还是以c源文件名称来命名的原因吧</strong>，可能要在task.json和launch.json文件下改。<ol><li>对的，task.json中args参数改动：：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;-g&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;file&#125;</span>&quot;</span>,</span><br><span class="line"><span class="string">&quot;-o&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;fileDirname&#125;</span>\\<span class="variable">$&#123;fileBasenameNoExtension&#125;</span>.exe&quot;</span>,</span><br><span class="line"></span><br><span class="line">改为:</span><br><span class="line"><span class="string">&quot;-g&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;workspaceFolder&#125;</span>\\*.c&quot;</span>,//c++代码就改这里后缀为.cpp</span><br><span class="line"><span class="string">&quot;-o&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;workspaceFolder&#125;</span>\\<span class="variable">$&#123;workspaceRootFolderName&#125;</span>.exe&quot;</span>,</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>launch.json文件改动如下：</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;program&quot;</span>: <span class="string">&quot;<span class="subst">$&#123;fileDirname&#125;</span>\\<span class="subst">$&#123;fileBasenameNoExtension&#125;</span>.exe&quot;</span>,</span><br><span class="line"><span class="comment">//改为</span></span><br><span class="line"><span class="string">&quot;program&quot;</span>: <span class="string">&quot;<span class="subst">$&#123;workspaceFolder&#125;</span>\\<span class="subst">$&#123;workspaceRootFolderName&#125;</span>.exe&quot;</span>,</span><br></pre></td></tr></table></figure><ol start="3"><li>这样就变成VS了，会编译项目文件下所有C文件，集成到以项目名称命名的程序下。</li></ol></li></ol></li></ol><h3 id="vscode配置python虚拟环境"><a class="markdownIt-Anchor" href="#vscode配置python虚拟环境"></a> VSCode配置python虚拟环境</h3><ol><li><strong>安装 Python 插件：</strong><ul><li>打开 VSCode。</li><li>在扩展视图中搜索并安装 Python 插件（一般是由 Microsoft 提供的 Python 插件）。</li></ul></li><li><strong>创建虚拟环境：</strong><ul><li><p>打开 VSCode 中的终端（可以使用 <code>Ctrl + </code> <code> </code> 或者点击顶部菜单的“视图”-&gt;“终端”）。</p></li><li><p>在终端中使用以下命令创建虚拟环境（假设你的项目在当前目录下，你可以替换 <code>venv</code> 为你喜欢的虚拟环境名称）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m venv venv</span><br></pre></td></tr></table></figure><p>如果你使用的是 Python 3.3 或更早版本，可以使用 <code>virtualenv</code> 替代 <code>venv</code>。</p></li></ul></li><li><strong>激活虚拟环境：</strong><ul><li><p>在终端中使用以下命令激活虚拟环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\venv\Scripts\activate</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>安装所需的包：</strong><ul><li>在虚拟环境中，使用 <code>pip</code> 安装你项目所需的依赖包，例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install package_name</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>在 VSCode 中选择虚拟环境：</strong><ul><li>打开你的项目文件夹。</li><li>在左下角的状态栏中，你应该能够看到当前使用的 Python 解释器。如果没有显示，点击并选择虚拟环境的 Python 解释器。</li></ul></li></ol><blockquote><p><a href="https://baijiahao.baidu.com/s?id=1767913548598914679&amp;wfr=spider&amp;for=pc">参考资料</a></p></blockquote><h4 id="python-pyinstall实现程序打包"><a class="markdownIt-Anchor" href="#python-pyinstall实现程序打包"></a> Python-Pyinstall实现程序打包</h4><p>示例：<code>pyinstaller -F -c -i icon.ico myscript.py</code>.</p><p><strong>具体参数见下表</strong>：</p><table><thead><tr><th>-F,-onefile</th><th>打包一个单个文件,如果你的代码都写在一个py文件的话,可以用这个,如果是多个py文件就别用</th></tr></thead><tbody><tr><td>-D,-onedir</td><td>打包多个文件，在dist中生成很多依赖文件，适合以框架形式编写工具代码，我个人比较推荐这样，代码易于维护</td></tr><tr><td>-K, –tk</td><td>在部署时包含TCLTK</td></tr><tr><td>-a, –ascii</td><td>不包含编码.在支持Unicode的python版本上默认包含所有的编码.</td></tr><tr><td>-d,-debug</td><td>产生debug版本的可执行文件</td></tr><tr><td>-w,-windowed,- noconsole</td><td>使用Windows子系统执行.当程序启动的时候不会打开命令行(只对Windows有效)</td></tr><tr><td>-c,-nowindowed,- console</td><td>使用控制台子系统执行(默认)(只对Windows有效)  pyintaller-c <a href="http://xxxx.py">xxxx.py</a></td></tr><tr><td>-s,-strip</td><td>可执行文件和共享库将run through strip.注意Cygwin的strip往往使普通的win32 Dll无法使用.</td></tr><tr><td>-X,-upx</td><td>如果有UPX安装(执行Configure.py时检测),会压缩执行文件(Windows系统中的DLL也会)(参见note)</td></tr><tr><td>-o DIR,-out=DIR</td><td>指定spec文件的生成目录,如果没有指定,而且当前目录是PyInstaller的根目录,会自动创建一个用于输出(spec和生成的可执行文件)的目录.如果没有指定,而当前目录不是PyInstaller的根目录,则会输出到当前的目录下.</td></tr><tr><td>-pDIR.-path=DIR</td><td>设置导入路径(和使用PYTHONPATH效果相似).可以用路径分割符(Windows使用分号,Linux使用冒号)分割,指定多个目录.也可以使 用多个-p参数来设置多个导入路径,让pyinstaller自己去找程序需要的资源</td></tr><tr><td>-icon=&lt;FILE.ICO&gt;</td><td>将file.ico添加为可执行文件的资源(只对Windows系统有效)，改变程序的图标  pyinstaller -i  ico路径 <a href="http://xxxxx.py">xxxxx.py</a></td></tr><tr><td>-icon= &lt;FILE.EXE,N&gt;</td><td>将file.exe的第n个图标添加为可执行文件的资源(只对Windows系统有效)</td></tr><tr><td>-V FILE,一 version=FILE</td><td>将verfile作为可执行文件的版本资源(只对Windows系统有效)</td></tr><tr><td>-n NAME,- name=NAME</td><td>可选的项目(产生的spec的)名字.如果省略,第一个脚本的主文件名将作为spec的名字</td></tr></tbody></table><p>参考文献</p><blockquote><p><a href="https://blog.csdn.net/BearStarX/article/details/81054134">pyinstaller参数介绍以及总结</a></p></blockquote><h3 id="git"><a class="markdownIt-Anchor" href="#git"></a> Git</h3><h4 id="下载安装"><a class="markdownIt-Anchor" href="#下载安装"></a> 下载安装</h4><p>略。建议安装在系统盘。</p><h4 id="配置github"><a class="markdownIt-Anchor" href="#配置github"></a> 配置github</h4><p>参考<a href="https://blog.csdn.net/thesat/article/details/122657537">hexo搭建博客</a>，这里详细讲了如何配置GitHub的shh密钥。<br>最后可运行<code>ssh -T git@github.com</code>,看是否出现<code>Hi Hushuangjun! You've successfully authenticated, but GitHub does not provide shell access.</code>,出现的话就说明配置成功了。</p><h4 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作"></a> 基本操作</h4><ol><li>基本版本控制<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init  <span class="regexp">//</span>初始化文件夹</span><br><span class="line"></span><br><span class="line">git add . <span class="regexp">//</span>添加目前文件路径下所有文件到暂存区</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">&quot;版本号(根据修改内容填写)&quot;</span>  <span class="regexp">//</span>提交</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>GitHub仓库(假设有一个test.git仓库)同步<ol><li>先在GitHub上创建仓库(test.git).</li><li>复制仓库地址.<code>https://github.com/Hushuangjun/test.git</code><br>然后在本地版本控制的文件夹下运行如下代码：</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https:<span class="regexp">//gi</span>thub.com<span class="regexp">/Hushuangjun/</span>test.git  <span class="regexp">//</span>将本地文件夹与远程服务器中仓库关联</span><br><span class="line"></span><br><span class="line">git push -u origin main <span class="regexp">//</span>推送到远程仓库，其中main是要推送的分支。</span><br></pre></td></tr></table></figure>如果你这个仓库是<code>fork</code>别人的，那么最好还需跟上游仓库(也就是原有仓库)建立连接，以便后续方便从上游仓库获取更新和为上游仓库的变更创建本地分支(做一个贡献者).<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream https:<span class="regexp">//gi</span>thub.com<span class="regexp">/真正作者的名字/</span>test.git</span><br></pre></td></tr></table></figure></li></ol><h3 id="vsccode-断点调试"><a class="markdownIt-Anchor" href="#vsccode-断点调试"></a> VSCcode-断点调试</h3><p>当在 Visual Studio Code (VSCode) 中进行断点调试时，通常会使用一系列调试控制命令来控制代码的执行。以下是一些常见的断点调试控制命令以及它们之间的区别：</p><ol><li><strong>继续：</strong><ul><li>从当前断点继续执行代码直到下一个断点或程序结束。如果没有设置断点，将一直执行到程序结束。</li></ul></li><li><strong>逐过程：</strong><ul><li>点一下运行当前行代码，并把高亮标志移动到下一行。如果当前行是一个函数，运行整个函数，而不会进入函数内部。</li></ul></li><li><strong>单步调试：</strong><ul><li>逐行执行代码，如果当前行包含函数调用，则进入该函数内部。</li></ul></li><li><strong>单步跳出：</strong><ul><li>执行完当前函数的剩余部分，并停在调用该函数的地方。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电子书籍查找教程</title>
      <link href="/2023/12/08/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/"/>
      <url>/2023/12/08/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="电子书查找教程"><a class="markdownIt-Anchor" href="#电子书查找教程"></a> 电子书查找教程</h2><h3 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h3><p>使用<strong>科学上网</strong>，在google上搜索相关书籍，可能会找到相关电子版。如下图所示。</p><span id="more"></span><div align="center"><img src="/2023/12/08/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/google搜索电子书.jpg" width="90%"></div><h3 id="方法二推荐"><a class="markdownIt-Anchor" href="#方法二推荐"></a> 方法二（推荐）</h3><ol><li><p>先在浏览器上安装<a href="https://greasyfork.org/zh-CN"><strong>油猴插件</strong></a>，</p><div align="center"><img src="/2023/12/08/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/浏览器安装油猴插件.jpg" width="90%"></div><p>然后在<a href="https://greasyfork.org/zh-CN/">https://greasyfork.org/zh-CN/</a> 上安装网页脚本，这里推荐一个如下：<br><a href="https://greasyfork.org/zh-CN/scripts/457620-%E5%9B%BE%E4%B9%A6%E4%BA%92%E5%8A%A9-%E5%9B%BE%E4%B9%A6%E9%A6%86%E5%8F%82%E8%80%83%E5%92%A8%E8%AF%A2%E8%81%94%E7%9B%9F-%E8%AF%BB%E7%A7%80">图书互助-图书馆参考咨询联盟-读秀</a></p><div align="center"><img src="/2023/12/08/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/油猴插件.jpg" width="90%"></div></li><li><p>然后打开<a href="http://www.ucdrs.superlib.net/"><strong>全国图书馆参考咨询联盟</strong></a>,(注册、登录过程省略)，输入自己一本想要的书，这时你会发现每本书下面都有一个<strong>图书互助</strong>，如下图所示。</p><div align="center"><img src="/2023/12/08/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/全国图书馆参考联盟查书.jpg" width="90%"></div></li><li><p>点击<strong>图书互助</strong>，会跳转到另一个网站：<a href="http://tushu.163pdf.xyz/">互助助手</a>,如果这本书有电子资源，则会提示如下：</p><div align="center"><img src="/2023/12/08/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/互助助手（能查到书）.jpg" width="70%"></div>如果显示如下画面，则这个网站（或者脚本）不能找到该资源。<div align="center"><img src="/2023/12/08/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/互助助手（未查到书）.jpg" width="70%"></div></li><li><p>如果能找到，则点击<strong>发起互助</strong>，可能会提示你登录（如果你没登录<strong>互助助手</strong>这个网站的话）。</p><div align="center"><img src="/2023/12/08/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/互助助手（登录）.jpg" width="70%"></div><p>然后你可以在这个网站上购买积分，步骤如下：</p><div align="center"><img src="/2023/12/08/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/卡密-1.jpg" width="70%"></div><div align="center"><img src="/2023/12/08/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/卡密-2.jpg" width="70%"></div><div align="center"><img src="/2023/12/08/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/卡密-34.jpg" width="70%"></div><div align="center"><img src="/2023/12/08/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/卡密-5.jpg" width="70%"></div><div align="center"><img src="/2023/12/08/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/卡密-6.jpg" width="70%"></div></li><li><p>登录之后，再次进入搜书界面，刷新一下，再点击<strong>图书互助</strong>，如下图所示：</p><div align="center"><img src="/2023/12/08/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/刷新卡密.jpg" width="70%"></div></li><li><p>然后再次跳转到<strong>互助助手</strong>，再次<strong>发起互助</strong>，过半分钟左右，就有百度网盘链接了。</p><div align="center"><img src="/2023/12/08/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/发起互助.jpg" width="70%"></div><div align="center"><img src="/2023/12/08/Useful%20tools/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/百度网盘链接.jpg" width="70%"></div></li></ol><p><strong>至此，你就能一元下载一本书的电子版啦！，比TB、PDD上商家实惠多了</strong>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大端与小端</title>
      <link href="/2023/12/08/Coding/01%E5%A4%A7%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%AB%AF/"/>
      <url>/2023/12/08/Coding/01%E5%A4%A7%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>最近做了小甲鱼<a href="https://fishc.com.cn/thread-74266-1-1.html"><strong>练习题</strong></a>，学习了什么是<a href="https://fishc.com.cn/thread-75394-1-1.html"><strong>大端和小端</strong></a>，后面有空来填坑。</p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>专业进阶学习</title>
      <link href="/2023/12/08/Study/%E4%B8%93%E4%B8%9A%E8%BF%9B%E9%98%B6/"/>
      <url>/2023/12/08/Study/%E4%B8%93%E4%B8%9A%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="结构动力学"><a href="#结构动力学" class="headerlink" title="结构动力学"></a>结构动力学</h2><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 结构设计学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>破局</title>
      <link href="/2023/11/13/Study/%E7%A0%B4%E5%B1%80/"/>
      <url>/2023/11/13/Study/%E7%A0%B4%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="c语言"><a class="markdownIt-Anchor" href="#c语言"></a> C语言</h2><span id="more"></span><h3 id="基本数据类型"><a class="markdownIt-Anchor" href="#基本数据类型"></a> 基本数据类型</h3><ol><li><p>getchar()函数</p><ol><li><strong>只能从键盘缓冲区接收字符，一次只能接收一个字符</strong>。如果之前有<code>scanf(&quot;%c&quot;,&amp;str);</code>类似语句，回车键<code>\n</code>也被会当作一个字符留在键盘缓冲区。如果不是char类型倒不要紧。</li><li>如果之前没有用scanf()接收过字符,那么使用getchar()函数时，需要先键入字符，<strong>按enter键后</strong>，键入的字符(串)进入缓冲区，然后getchar会从中取一个字符(按输入的顺序)，以后每次调用getchar()都会从缓冲区接收一个字符，直至缓冲区字符用完，再重复以上步骤。</li><li>getchar()函数的返回值也不是字符而是一个整型.(读取成功时就返回该字符的ASCⅡ值，失败时就返回一个-1。)</li><li>典型例题：加密电文，所有大小写英文字母＋4(ASCII码) 循环，其余字符不变。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> str;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> ( ; (str=getchar()) != <span class="string">&#x27;\n&#x27;</span> ; )&#123;</span><br><span class="line">      <span class="keyword">if</span> (str&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp; str &lt;= <span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>+(str+<span class="number">4</span>-<span class="string">&#x27;a&#x27;</span>)%<span class="number">26</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (str &gt;= <span class="string">&#x27;A&#x27;</span>&amp;&amp; str &lt;= <span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span>+(str+<span class="number">4</span>-<span class="string">&#x27;A&#x27;</span>)%<span class="number">26</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(str);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>scanf()函数</p><ol><li><p>scanf()函数返回值是是成功读取并赋值的参数的数量。<br>scanf()函数返回值分为3种：<br>(1)返回正整数。表示正确输入参数的个数。<br>(2)返回整数0。表示用户的输入不匹配，无法正确输入任何值。<br>(3)返回-1。表示输入流已经结束。在Windows下，用户按下CTRL+Z（会看到一个^Z字符）再按下回车（可能需要重复多次），就表示输入结束；Linux/Unix下使用CTRL+D表示输入结束。</p><p>参考如下例题：<a href="https://fishc.com.cn/thread-237278-1-1.html">计算输入整数满足正确算式的数量</a>.<br>上述例题的两种解法：(链接中已给出一种，下给出另一种)</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,d[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> judge = <span class="number">1</span>,count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; judge;)&#123; <span class="comment">//判断条件是judge不为0.</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;<span class="number">3</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d[j]);</span><br><span class="line">            <span class="keyword">if</span> (getchar() == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                judge = <span class="number">0</span>; <span class="comment">//遇到换行符即表示输入结束。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">3</span> &amp;&amp; (d[<span class="number">0</span>] + d[<span class="number">1</span>] == d[<span class="number">2</span>]))&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>scanf()也是从键盘缓冲区得到输入，一般来说，遇到换行符<code>\n</code>就表示输入项结束了，但在上述例子<a href="https://fishc.com.cn/thread-237278-1-1.html">计算输入整数满足正确算式的数量</a>中，scanf由于一次性需要接收三个参数，此时换行符<code>\n</code>就不起作用了，需要手动敲<code>ctrl + z</code>再按回车。<strong>windows上，<code>ctrl + z</code>就表示输入项的结束</strong>。具体可参考<a href="https://blog.csdn.net/i6223671/article/details/89041492">详解输入输出流结束标志ctrl+z和EOF</a>.</p></li></ol></li><li><p>逗号表达式<br>逗号表达式一般形式为: <code>expr1, expr2, expr3,...,exprn</code>.<br>逗号表达式从左到右依次求值，每个表达式的值被忽略，除了最后一个表达式。逗号表达式的值就是最后一个表达式的值。</p></li><li><p>运算符优先级及结合性<br>结论：<strong>先计算优先级大的，相同优先级根据结合性计算</strong>。</p><div align="center"><img src="/2023/11/13/Study/%E7%A0%B4%E5%B1%80/运算符优先级及结合性.jpg" width="90%"></div>观察如下代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span> x = <span class="number">5</span>, y;</span><br><span class="line"></span><br><span class="line">   y = <span class="number">2</span> * x++;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;x = %d&quot;</span>,x);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;y = %d&quot;</span>,y);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是:</p><blockquote><p>x = 6; y = 10;</p></blockquote><p>于是疑问出现了，自增运算符<code>++</code>优先级不是大于乘<code>*</code>吗？不是先自增再乘嘛，这样<code>y = 2*6 = 12</code>.<br>其实：<strong>程序确实先进行自增运算符，但<code>++x和x++</code>返回的结果是不同的，然后再赋值给y。特别是x++，它的返回值就是x，而++x的返回值是x + 1, 所以造成一种假象，以为先进行了乘法运算</strong>。<br>小试牛刀：</p><blockquote><p>关于<code>str = '!'; 48 &lt;= str &lt;= 57</code>为啥总是得到1？</p></blockquote><p>因为<code>&lt;=</code>的结合性是自左向右，故先会计算<code>48 &lt;= str</code>,此时str = ‘!’,ASCII值是33，故返回值是1.再计算<code>1 &lt;= 57</code>,返回值是1.由此可以看出学了python之后，再学C感觉步骤很啰嗦。但正是因为步骤啰嗦（分类齐全，条理清晰），故C速度很快。</p></li></ol><h3 id="选择结构程序设计"><a class="markdownIt-Anchor" href="#选择结构程序设计"></a> 选择结构程序设计</h3><ol><li>注意<code>if - else if - else</code>如果<strong>没有大括号就遵循就近原则</strong>，所以写的时候尽量带上大括号。例如:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">1</span>,b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">      <span class="keyword">if</span> (b &gt; c)</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,b);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>最后结果什么也不会输出！！因为其相当于<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a&gt;b)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> (b &gt; c)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,b);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>switch</code>选择语句：注意表达式A的值必须为整型数据（当然包括字符型），而a、b…必须是常量或者常量表达式。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式A)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">case</span> a:  表达式<span class="number">1</span>  ; <span class="keyword">break</span>;  <span class="comment">//必须加上break，否则后续case会一直执行，直到break或者全部读完。</span></span><br><span class="line">   <span class="keyword">case</span> b:  表达式<span class="number">2</span>  ; <span class="keyword">break</span>;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">default</span>:  表达式n ; <span class="keyword">break</span>;  <span class="comment">// 可以不用break,反正都结束了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>C语言中唯一一个三目运算符：条件运算符(<code>? :</code>)，对应表达式就是条件表达式:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a &gt; b ? a:b</span><br><span class="line"><span class="comment">//条件语句</span></span><br><span class="line">c = a &gt; b ? a:b ;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">if</span> (a&gt;b)&#123;</span><br><span class="line">   c = a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">   c = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="循环结构程序设计"><a class="markdownIt-Anchor" href="#循环结构程序设计"></a> 循环结构程序设计</h3><ol><li><code>while</code>循环：表达式为真，进入循环，直至表达式为假或者<code>break;</code>跳出循环.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line">   语句<span class="number">1</span>;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>do while</code>循环：特别注意while后面还有个分号<code>;</code>.  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">   语句<span class="number">1</span>；</span><br><span class="line">   ...</span><br><span class="line">&#125; <span class="keyword">while</span> (表达式) ;  </span><br></pre></td></tr></table></figure></li><li><code>for</code>循环:其中表达式1和3可以为<strong>逗号表达式</strong>，表达式2是判断条件，为真的话继续。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (表达式<span class="number">1</span>; 表达式<span class="number">2</span>; 表达式<span class="number">3</span>) </span><br><span class="line">&#123;</span><br><span class="line">   语句<span class="number">1</span>;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于:</span></span><br><span class="line">表达式<span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (表达式<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">   语句<span class="number">1</span>;</span><br><span class="line">   ...</span><br><span class="line">   表达式<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h3><ol><li>定义数组<blockquote><p>一维数组定义：(二维数组同理)<br>类型符  数组名[常量表达式]</p></blockquote>特别注意是<strong>常量表达式</strong>，不能是<strong>变量</strong>。<br>但是！C99推出了<strong>变长数组</strong>(Variable Length Array，VLA),它允许在运行时动态地定义数组的长度，而不是在编译时指定一个常量长度，但一旦一定，在其生命周期内大小不可改变。<br>例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> rows, cols;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the number of rows: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;rows);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the number of columns: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cols);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> matrix[rows][cols];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他操作...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>同时，值得注意的是，<strong>VLA不允许在定义的时候初始化</strong>！<br>例如<code>int matrix[rows][cols] = &#123;0&#125;;</code>，编译器会报错。</li><li>二维数组是一维数组线性拓展得到的，也是以线性的方式存储的。</li><li>数组名的值数组第一个元素的地址，相当于是一个常量，是不能被赋值的。因此下列数组初始化是错误的:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&quot;string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure></li><li>如何直接输出字符串？或者输入字符串?<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出, str是已定义的字符串数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">put(str);  <span class="comment">// 特别注意put不能输出多个字符串,而printf()可以。</span></span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str); <span class="comment">//由于str的值就是数组第一个元素的地址，故不需要取值符`&amp;`.同时，输入的字符串大小应不大于定义的字符数组的大小。</span></span><br><span class="line">get(str); <span class="comment">//同理，一次只能接收一个字符串数组。</span></span><br></pre></td></tr></table></figure></li><li>字符串处理函数</li></ol><table><thead><tr><th>函数名称</th><th>作用</th><th>返回值</th></tr></thead><tbody><tr><td>puts(str)</td><td>输出<strong>单个</strong>字符串</td><td>-</td></tr><tr><td>gets(str)</td><td>输入<strong>单个</strong>字符串</td><td>-</td></tr><tr><td>strlen(str)</td><td>测量字符串的长度</td><td>返回字符串的长度(不包括<code>\0</code>)</td></tr><tr><td><strong>sizeof(str)</strong></td><td>测量字符串的内存大小</td><td>返回字符串的内存大小(注意，如果字符串没规定大小，如<code>char str[] = &quot;string;</code>,则返回值包括<code>\0</code>,如果规定大小了，则返回的值该大小所占字节。)</td></tr><tr><td>补充：sizeof(array)</td><td>测量其他类型数组的内存大小</td><td>返回其他类型数组的内存大小(此时并没有<code>\0</code>的烦恼了)</td></tr><tr><td>strcat(str1,str2)</td><td>将<strong>字符串2</strong>接到<strong>字符串1</strong>后面</td><td>返回的是字符串1的地址</td></tr><tr><td>strcpy(str1,str2)</td><td>将字符串2(包括<code>\0</code>)复制到字符串1中</td><td>返回的是字符串1的地址</td></tr><tr><td>strncpy(str1,str2)</td><td>将字符串2前n个字符（n不多于字符串长度）复制到字符串1中</td><td>返回的是字符串1的地址</td></tr><tr><td>strlwr(str)</td><td>将字符串中大小写字母变成<strong>小写字母</strong></td><td>不返回任何值，对于字符串是原位修改</td></tr><tr><td>strupr(str)</td><td>将字符串中大小写字母变成<strong>大写字母</strong></td><td>不返回任何值，对于字符串是原位修改</td></tr><tr><td>strcpm(str1,str2)</td><td>依次比较str1和str2中字符的大小，按照ASCII码比较</td><td>str1==str2,则返回0；str1 &gt; str2,则返回一个正整数;str1 &lt; str2，则返回一个负整数.</td></tr></tbody></table><h3 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h3><ol><li><p>指针与指针变量<br>指针变量也是一个变量，占用的字节大小取决于其<strong>存储的内存地址</strong>的大小，而常说的指针=“内存地址”。（也是我们常说的变量，但变量只有我们和编译器知道，编译器在编译时，变量名和内存地址有一个一一对应的关系）<br><strong>需要说明的是</strong>：后续所讲<code>指针</code>多指<code>指针变量</code>,例如p指向变量a,完整的说法是：p的值是变量a的地址。</p><blockquote><hr></blockquote><p>前提:<code>int x = 10, *y; y = &amp;x;</code><br><strong>重点：可以认为*y == x。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明指针变量，&amp;为取地址运算符</span></span><br><span class="line"><span class="type">char</span> *pa = &amp;a;   <span class="comment">//用char是因为指针变量所储存的内存地址所对应的数据类型是char.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,pa); <span class="comment">//打印内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*pa); <span class="comment">//打印变量a的值，这里*是取值运算符。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也即：</span></span><br><span class="line">*(&amp;a) = a;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面以小甲鱼的一道课后习题来介绍：<br>Q:请问下边代码执行后，打印机的结果是什么？另外，*b 是左值（l-value）还是右值（r-value）？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="type">int</span> a = <span class="number">110</span>;</span><br><span class="line">      <span class="type">int</span> *b = &amp;a;</span><br><span class="line">      *b = *b - <span class="number">10</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>打印结果是 a = 10.<br>第一个问题：定义指针变量 b 的时候，存放的是变量 a 的地址。在此之后，*b 即对变量 a 的间接访问（通过地址访问 a 变量）。所以 *b = *b - 10; 相当于 a = a - 10; 也就是说，<strong>通过指针对一个变量间接访问，你可以理解为把它作为那个变量本身使唤</strong>（即 *b == a）.<br>第二个问题：<strong>指针变量 b 既是左值，也是右值</strong>。看 *b = *b - 10; 这个语句，赋值号右边，*b 间接访问变量 a 的值，因为用的是它的值，所以是右值；赋值号左边，*b 用于定位变量 a 的存储位置，然后将右边表达式的值存放进去，所以此时为左值.</p></blockquote></li><li><p>一维数组(不特别说明，数组均指一维数组)与指针关系<br><strong>数组名==指针变量</strong>，数组名储藏着数组第一个元素的地址，对于<strong>字符数据类型</strong>，可以直接用指针创建数组，下面代码演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> *a = <span class="string">&quot;OUC&quot;</span>;  </span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,a[i]); <span class="comment">//此处相当于是 a[i] = *(a+i)</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而对于int等类型，通过指针创建是行不通，究其原因，是因为字符数组就是第一个字符的地址（指针变量），且字符数组名和其他数组名一样，也是指针变量，指向数组第一个元素。</p><blockquote><p>char str[] = “string”;<br>上述str和&quot;string&quot;都可以当作指针变量。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*(<span class="string">&quot;sting&quot;</span>)); <span class="comment">//会输出&#x27;s&#x27;.</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过指针访问数组</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">   <span class="type">int</span> *p = a;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;*p = %d, *(p+1) = %d.\n&quot;</span>,*p, *(p+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果就是:</p><blockquote><p>*p = 1, *(p+1) = 2.</p></blockquote><p>这就是通过<strong>指针间接访问数组的办法，区别于下标直接访问法</strong>。<br><strong>既然数组名也是一个指针变量，那么同理也用数组名进行访问</strong>，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  </span><br><span class="line">   </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;*a = %d, *(a+1) = %d.\n&quot;</span>,*a, *(a+<span class="number">1</span>));  <span class="comment">//这个为后续指针数组做下铺垫，例如int (*ptr)[5] = &amp;a;  这里ptr是一个指针变量，存着数组a的地址，*ptr就是数组a，也就代表着数组第一个元素的地址。从而有</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   int (*ptr)[5] = &amp;a;</span></span><br><span class="line"><span class="comment">   int i;</span></span><br><span class="line"><span class="comment">   for (i = 0; i&lt;5; i++)&#123;</span></span><br><span class="line"><span class="comment">      printf(&quot;%d&quot;,*(*ptr+i));</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指针与数组的区别<br>指针变量是左值(lvalue)，可以修改的；而数组名是地址常量，不可以修改，故不是左值。<br>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> str[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">   <span class="type">int</span> *target = str;  </span><br><span class="line">   <span class="type">int</span> count  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (*target++ != <span class="number">3</span>)  <span class="comment">//此处必须用指针变量，不能用数组名。</span></span><br><span class="line">   <span class="comment">// 这里*target++是啥呢？ 由于增运算符(变量++)的优先级大于取值运算符(*)，故先进行target++,再取值*，相当于*(target++)。</span></span><br><span class="line">   <span class="comment">//同时，还需注意，自增运算符在变量后面，故取值符(*)取用的是未自增前的值。</span></span><br><span class="line">   &#123;</span><br><span class="line">      count++;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;总共有%d个数字\n&quot;</span>,count);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小甲鱼作业S1E22第2题</strong>：</p><blockquote><p>请问 str[20] 是否可以写成 20[str]？<br>A: C 语言中，<code>a[b]</code> 被解释为 <code>*(a + b)</code>,故两者等价。</p></blockquote></li><li><p>指针数组和数组指针<br>指针数组是指数组元素全为指针的数组；数组指针是一个指针，它指向的是一个数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区分下列哪个是指针数组，哪个是数组指针</span></span><br><span class="line"><span class="type">int</span> *p1[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*p2)[<span class="number">5</span>];  <span class="comment">//int (*p)[5]就相当于int a[5]，a就是数组地址！！！ (区别于数组首地址，后面会讲到)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[ ]优先级大于*；虽然[]和()优先级一样，但结合性是从左到右，故第一个是指针数组，第二个是数组指针。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>指针数组的一个用途：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="type">char</span> *p[<span class="number">3</span>] = &#123;   <span class="comment">//由于指针数组存放的都是指针，而数组名就是指针变量。</span></span><br><span class="line">      <span class="string">&quot;让编程改变世界&quot;</span>,</span><br><span class="line">      <span class="string">&quot;Just do it!&quot;</span>,</span><br><span class="line">      <span class="string">&quot;一切皆有可能&quot;</span></span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p[i]);  <span class="comment">// %s是通过字符串首地址输出字符串</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于数组指针还有一个坑，数组指针指向的是一个数组，而我们之前常用<code>int *p = temp;</code>(此处temp是一个已定义的整型数组)来将<code>指针指向数组</code>,但实际上，<strong>指针只是指向了数组第一个元素的地址</strong>。现在我们要想数组指针指向整个数组，需使用<code>int (*p)[5] = &amp;temp</code>;这里<code>&amp;temp</code>相当于将整个数组看作一个整体来看待的。(必须清楚的是，数组第一个元素的地址跟整个数组的地址是相同的。)举例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> temp[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">   <span class="comment">// int (*p)[5] = temp;  //输出也可以，因为把数组当作整体给出地址还是数组首地址，但编译器会提醒。</span></span><br><span class="line">   <span class="type">int</span> (*p)[<span class="number">5</span>] = &amp;temp;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(*p + i)); </span><br><span class="line">      <span class="comment">// p是一个指向数组(并非指向数组第一个元素)的指针，*p就是取出该指针对应的内容，也就是数组temp，即*p=temp，而temp又是数组第一个元素的地址，可以当作指针，并进行指针运算。</span></span><br><span class="line">      <span class="comment">//注意，此时*(*p) = *(temp) = 数组temp的第一个元素.有点嵌套指针的意味了！</span></span><br><span class="line">      <span class="comment">//于是，上述输出也可写成: printf(&quot;%d\n&quot;,(*p)[i]);</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>小甲鱼课后作业：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *<span class="built_in">array</span>[<span class="number">5</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;FishC&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Five&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Star&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Good&quot;</span>,</span><br><span class="line">        <span class="string">&quot;WoW&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span> *(*p)[<span class="number">5</span>] = &amp;<span class="built_in">array</span>;  <span class="comment">//定义指向包含5个指针的数组的指针，也就是说这个数组的类型是字符指针类型，故定义相同类型(char *)的数组指针</span></span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; *(*(*p+i)+j) != <span class="string">&#x27;\0&#x27;</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,*(*(*p+i)+j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处<code>p</code>相当于指向了一个二维数组。但不能用指向二维数组的指针定义方式来定义，因为它<strong>实际上是指向包含5个指针的数组</strong>。而定义指向二维数组的指针，详见第9条。</p></li><li><p>指针与二维数组：<br>观察下述代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">4</span>][<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;array is %p\n&quot;</span>,<span class="built_in">array</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;array +1 is %p\n&quot;</span>,<span class="built_in">array</span>+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array is 0xbfc34320<span class="built_in"></span></span><br><span class="line"><span class="built_in">array </span>+1 is 0xbfc34334</span><br></pre></td></tr></table></figure><p>由此得出，二维数组的数组名指向包含5个元素的数组(也就是第一行元素所构成的数组)，<strong>二维数组名实际上就是数组指针</strong>！！！<br>同时也可明白，<code>array + 1</code>则指向第二行构成的数组，即此处的<code>array +1 </code>相当于前述的<code>p</code>.</p><p>二维数组名也可赋值给数组指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span> <span class="built_in">array</span>[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">      &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">      &#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>&#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="type">int</span> (*p)[<span class="number">3</span>] = <span class="built_in">array</span>; <span class="comment">// p指向第一行元素构成的数组</span></span><br><span class="line">   <span class="type">int</span> (*n)[<span class="number">3</span>] = <span class="built_in">array</span> + <span class="number">1</span>;<span class="comment">// n指向第二行元素构成的数组</span></span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,(*p)[i]); </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,(*n)[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p); <span class="comment">// 输出第一行元素构成的数组的地址。</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,<span class="built_in">array</span>);<span class="comment">// 输出第一行元素构成的数组的地址。</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;(*<span class="built_in">array</span>)); <span class="comment">// 输出第一行元素构成的数组的地址。(注意，并非数组的第一个元素，尽管两者数值上相等。)</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,*p); <span class="comment">//输出第一行元素构成的数组的第一个元素的地址。</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,**(p+<span class="number">1</span>));<span class="comment">// p是第一行元素构成的数组的地址，(p+1)则是第二行元素构成的数组的地址。</span></span><br><span class="line">   <span class="comment">//因为二维数组在内存中也是线性存储的，p+1表示指针往后移3*4=12个字节，也就是第二行元素构成的数组的地址。</span></span><br><span class="line">   <span class="comment">//即p+1指向第二行元素构成的数组。</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>void指针与null指针<br>Void指针我们把它称之为通用指针，就是可以指向任意类型的数据。也就是说，<strong>任何类型的指针都可以赋值给Void指针。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">   <span class="type">int</span> *p = &amp;num;</span><br><span class="line">   <span class="type">char</span> *n = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">   <span class="type">void</span> *ye;</span><br><span class="line"></span><br><span class="line">   ye = p;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;ye:%p p:%p\n&quot;</span>,ye,p);</span><br><span class="line">   ye = n;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;ye:%p n:%p\n&quot;</span>,ye,n); </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，又引出一个问题，void指针如何取值？编译器怎么知道？所以，强制转换符<code>(强制转换类型 *)</code>又出现了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ye:%d\n&quot;</span>,*((<span class="type">int</span> *)ye));  </span><br></pre></td></tr></table></figure><p>NULL指针，即空指针，不指向任何一个地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空指针的宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  NULL ((void *)0)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;  <span class="comment">//定义空指针，解引用(取值)的话程序会报错。</span></span><br><span class="line"><span class="comment">//也可以写成 int *p = (void *)0 ;</span></span><br><span class="line"><span class="type">int</span> *m; <span class="comment">//还未初始化，称为野指针。</span></span><br></pre></td></tr></table></figure><p>注意，是NULL而不是NUL（在ASCII表中）。</p><ol><li>NULL用于指针和对象，表示控制，指向一个不被使用的地址。</li><li>NUL(‘\0’)表示字符串的结尾。</li></ol><p>小甲鱼S1E24：指针和二维数组第5题出现了<code>(int (*)[3])</code>强制类型转换符。具体代码如下：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> <span class="built_in">array</span>[<span class="number">9</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="type">int</span> (*p)[<span class="number">3</span>] = (<span class="type">int</span> (*)[<span class="number">3</span>])&amp;<span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p[<span class="number">2</span>][<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>(int (*)[3])&amp;array</code>等号右边强制将 array 这个一位数组重新划分成3*3的二维数组，p等于二维数组。这与前面第6条所说：<code>二维数组名就是数组指针</code>相呼应。小甲鱼的答案有点问题，p并不是指向二维数组，p就是二维数组名，指向二维数组第一行元素构成的数组。</p></li><li><p>指向指针的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line">   <span class="type">int</span> *p = &amp;a;</span><br><span class="line">   <span class="type">int</span> **pp = &amp;p;  <span class="comment">//此即指向指针的指针</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//验证是否指向指针</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;p = %p\n*pp = %p&quot;</span>,p,*pp);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那指向指针的指针有啥用呢？观察如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">char</span> *cBooks[] = &#123;</span><br><span class="line">      <span class="string">&quot;C primer plus&quot;</span>,</span><br><span class="line">      <span class="string">&quot;带你学C带你飞&quot;</span>,</span><br><span class="line">      <span class="string">&quot;C与指针&quot;</span></span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="type">char</span> **charm;</span><br><span class="line"></span><br><span class="line">   charm = &amp;cBooks[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,*charm);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可以看出，指向指针的指针至少有以下两个好处：</p><ul><li>避免重复分配内存；</li><li>只需对一处进行修改.</li></ul></li><li><p>指向指针的指针与二维数组<br>观察如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">25</span>,<span class="number">36</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="type">int</span> **p = <span class="built_in">array</span>;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*(*(p+i)+j));   <span class="comment">//对应着case one</span></span><br><span class="line">        <span class="comment">//printf(&quot;%d&quot;,*(*(array+i)+j));  //对应case two</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Case one:</p><blockquote><p>由于p是一个指针，故p+i就是指针移动<code>i</code>个<code>int</code>数据类型所占的字节。例如，i = 1,则p+1就是第一行元素构成数组的地址+4，如果再取值<code>*</code>,由于找不到对应的内容(因为无论是整个数组地址还是数组第一个元素的地址，数值上都等于数组第一个元素的地址，且二维数组的行并不一定在内存中是连续存储的。）因此，使用错误的指针类型可能导致对内存的错误访问，从而触发段错误<code>sgementation default</code>。</p></blockquote><p>Case two:</p><blockquote><p>array可行，因为array本身可看作数组指针，array+1就是移向下一行。</p></blockquote><p>因此，要想正确输出，需将上述代码改为如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">4</span>] = <span class="built_in">array</span>;  <span class="comment">//利用数组指针</span></span><br></pre></td></tr></table></figure><p>必须要注意：<strong>上面那个<code>[4]</code>不能省略，就是它决定p+1跨多少个字节</strong>。<br>Ps:B站这一节课有弹幕指出：可以写成<code>(*p)[3][4] = &amp;array</code>,这个其实相当于定义了一个指向二维数组的指针。代码可修改如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">25</span>,<span class="number">36</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>][<span class="number">4</span>] = &amp;<span class="built_in">array</span>;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,*(*(*p+i)+j)); <span class="comment">//由于p指向整个二维数组，故*p就是二维数组，指向二维数组第一行元素构成的数组，这样也就弱化为指向数组的指针了，同前述第6节。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>常量和指针<br>常量：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">520</span>, <span class="string">&#x27;A&#x27;</span>, <span class="params">...</span></span><br></pre></td></tr></table></figure><p>常变量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>; <span class="comment">//这样使得a只能读，不能修改，相当于常量，**但不是常量**.</span></span><br></pre></td></tr></table></figure><p>定义指向常量的指针(<strong>区别于后续所讲常量指针</strong>):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;num;  <span class="comment">//定义指向常量的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果尝试修改指向常量的指针指向的值，则会发生错误</span></span><br><span class="line">*p = <span class="number">1250</span>;</span><br><span class="line"><span class="comment">//error: assignment of read-only location &#x27;*p&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果尝试修改指向常量的指针的值，这是允许的，相当于该指针不指向常量num.</span></span><br><span class="line"><span class="type">int</span> cnum = <span class="number">250</span>;</span><br><span class="line">p = &amp;cnum;</span><br><span class="line"><span class="comment">//编译通过。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时如果改变p指向的值，则报错：</span></span><br><span class="line">*p = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//但是，我们如果修改cnum的值：</span></span><br><span class="line">cnum = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//编译成功。</span></span><br></pre></td></tr></table></figure><p>指向常量的指针-总结：</p><ul><li>指针可以修改为指向不同的常量</li><li>指针可以修改为指向不同的变量</li><li>可以通过解引用来读取指针指向的数据</li><li>不可以通过解引用修改指针指向的数据</li></ul><p>那什么是常量指针呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p = &amp;num; <span class="comment">//定义指向非常量的常量指针</span></span><br></pre></td></tr></table></figure><p>特性：</p><ul><li>指针本身值不可改变，指向的值可修改。</li><li><strong>典型例子就是数组名</strong>。</li></ul><p>定义指向非常量的常量指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> cnum = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p = &amp;num;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改指向的值：</span></span><br><span class="line">*p = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//编译成功;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改本身值：</span></span><br><span class="line">p = &amp;cnum;</span><br><span class="line"><span class="comment">//报错：error: assignment of read-only variable &#x27;p&#x27;;</span></span><br></pre></td></tr></table></figure><p>如果定义一个指向常量的常量指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> cnum = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p = &amp;cnum;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果此时既修改指针的值，又修改指针所指向的值，则会报两个错：</span></span><br><span class="line">*p = <span class="number">20</span>;</span><br><span class="line">p = &amp;num;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error:error: assignment of read-only location &#x27;*p&#x27;;</span></span><br><span class="line"><span class="comment">// error:error: assignment of read-only variable &#x27;p&#x27;;</span></span><br></pre></td></tr></table></figure><p>可以看出其特点：</p><ul><li>指针本身值不可改变，指向的值也不可修改。</li></ul><p>但有趣的一点是，如果你定义了指向常量的常量指针，但接受的地址不是常量，还是可以通过改变该非常量来修改指针所指向的值的。如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> cnum = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p = &amp;num;</span><br><span class="line"></span><br><span class="line">num = <span class="number">111</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出111.</span></span><br></pre></td></tr></table></figure><p>又进一步引出：指向 “指向常量的常量指针” 的指针。<br>看到名字别害怕，<strong>去掉定语，也即指向指针的指针</strong>。</p><blockquote><p>要记住，要指向 “指向常量的常量指针”，自己也必须是指向常量的常量指针。</p></blockquote><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> cnum = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p = &amp;num;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ** <span class="type">const</span> pp = &amp;p; <span class="comment">//定义指向 “指向常量的常量指针” 的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//验证pp指向p</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pp = %p, &amp;p = %p\n&quot;</span>,pp,&amp;p);</span><br><span class="line"><span class="comment">//验证*pp == p == &amp;num</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*pp = %p, p = %p,&amp;num = %p\n&quot;</span>,*pp,p,&amp;num);</span><br><span class="line"><span class="comment">//验证**pp == *p == num;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;**pp = %d, *p = %d, num = %d\n&quot;</span>,**pp,p,num);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>土木工程专业课程设计</title>
      <link href="/2023/10/08/Study/%E5%9C%9F%E6%9C%A8%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/10/08/Study/%E5%9C%9F%E6%9C%A8%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="结构力学课程设计"><a href="#结构力学课程设计" class="headerlink" title="结构力学课程设计"></a>结构力学课程设计</h3><span id="more"></span><div class="pdf-container" data-target="结构力学课程设计.pdf" data-height="500px"></div><h3 id="混凝土楼盖课程设计"><a href="#混凝土楼盖课程设计" class="headerlink" title="混凝土楼盖课程设计"></a>混凝土楼盖课程设计</h3><div class="pdf-container" data-target="混凝土课程设计.pdf" data-height="500px"></div><h3 id="房屋结构课程设计"><a href="#房屋结构课程设计" class="headerlink" title="房屋结构课程设计"></a>房屋结构课程设计</h3><div class="pdf-container" data-target="房屋结构课程设计.pdf" data-height="500px"></div><h3 id="基础工程课程设计"><a href="#基础工程课程设计" class="headerlink" title="基础工程课程设计"></a>基础工程课程设计</h3><div class="pdf-container" data-target="基础工程课程设计.pdf" data-height="500px"></div><h3 id="钢结构课程设计"><a href="#钢结构课程设计" class="headerlink" title="钢结构课程设计"></a>钢结构课程设计</h3><div class="pdf-container" data-target="钢结构课程设计.pdf" data-height="500px"></div><h3 id="土木工程施工课程设计"><a href="#土木工程施工课程设计" class="headerlink" title="土木工程施工课程设计"></a>土木工程施工课程设计</h3><div class="pdf-container" data-target="土木工程施工课程设计.pdf" data-height="500px"></div>]]></content>
      
      
      <categories>
          
          <category> 结构设计学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>结构设计杂谈</title>
      <link href="/2023/10/05/Study/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/"/>
      <url>/2023/10/05/Study/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<h3 id="内力组合相关疑惑"><a class="markdownIt-Anchor" href="#内力组合相关疑惑"></a> 内力组合相关疑惑</h3><p>以框架结构为例，<strong>抗震设计</strong>时，内力组合遵循一下原则：（电脑也是这么算的，具体可以参见<strong>广厦计算结果</strong>）<span id="more"></span><br>注意：下面γGE取1.2是老规范，新规范是1.3.</p><div align="center"><img src="/2023/10/05/Study/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/内力组合（一）.jpg" width="70%"></div><div align="center"><img src="/2023/10/05/Study/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/内力组合（二）.jpg" width="70%"></div><p>关键要义：<strong>在同一个组合下一直算（包括强柱弱梁等内力调整，要在同一个组合内调整），然后再在不同组合中取最不利的值</strong>。<br>广厦内力组合如下，验证了上面的想法。</p><div align="center"><img src="/2023/10/05/Study/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/广厦内力组合.jpg" width="90%"></div><h3 id="振型参与质量系数与振型有效质量系数的区别"><a class="markdownIt-Anchor" href="#振型参与质量系数与振型有效质量系数的区别"></a> 振型参与质量系数与振型有效质量系数的区别</h3><ol><li>振型参与质量（系数）是振型有效质量（系数）的推广。</li></ol><div align="center"><img src="/2023/10/05/Study/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/振型参与质量系数与振型有效质量系数.jpg" width="70%"></div><h3 id="焊接纵向-横向残余应力的理解"><a class="markdownIt-Anchor" href="#焊接纵向-横向残余应力的理解"></a> 焊接纵向、横向残余应力的理解</h3><p>1.焊接纵向残余应力<br>所谓<strong>纵向</strong>，就是<strong>应力方向与焊缝长度方向平行</strong>。如下图所示。</p><div align="center"><img src="/2023/10/05/Study/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/焊接纵向残余应力.jpg" width="70%"></div><div align="center"><img src="/2023/10/05/Study/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/焊接纵向残余应力-1.jpg" width="70%"></div><p>对于是<strong>拉应力还是压应力</strong>，应该这么理解：靠近焊缝的部分，在冷却时，受到两端已经冷却（或者说热影响不大）的区域限制，限制它<strong>收缩</strong>，故在其中产生了拉应力。由于板件<strong>未受外力</strong>，截面必然<strong>平衡</strong>，故两端的纵向残余应力为<strong>压应力</strong>。<br>2.焊接横向残余应力<br>所谓<strong>横向</strong>就是<strong>垂直于焊缝长度方向</strong>，例如两块板对接焊，当焊缝<strong>纵向收缩</strong>时，两块板件有向相反反向弯曲的趋势，造成焊缝中部<strong>两端受压，中间受拉</strong>。如下图所示。</p><div align="center"><img src="/2023/10/05/Study/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/焊接横向残余应力.jpg" width="70%"></div><h3 id="剪力墙按受力特性的分类及其受力特征"><a class="markdownIt-Anchor" href="#剪力墙按受力特性的分类及其受力特征"></a> 剪力墙按受力特性的分类及其受力特征</h3><ol><li><strong>整体墙</strong><br>定义：无洞口的剪力墙或剪力墙上开有一定数量的洞口，但洞口的面积不超过墙体面积的16%，且洞口至墙边的净距及洞口之间的净距大于洞孔长边尺寸时，可以忽略洞口对墙体的影响，这种墙体称为整体剪力墙。<br>受力特征：整体剪力墙的受力状态如同竖向悬臂梁，截面变形后仍符合平面假定，<strong>因而截面应力可按材料力学公式计算</strong>，变形属弯曲型。</li><li><strong>整体小开口墙</strong><br>定义：当剪力墙上所开洞口面积稍大且超过墙体面积的16%时，在水平荷载作用下，这类剪力墙截面上的正应力分布略偏离了直线分布的规律，变成了相当于在整体墙弯曲时的直线分布应力之上叠加了墙肢局部弯曲应力，当墙肢中的局部弯矩不超过墙体整体弯矩的15%时，其截面变形仍接近于整体截面剪力墙，这种剪力墙称之为小开口整体剪力墙。<br>受力特征：<strong>对于小开口剪力墙，其截面变形大体上仍符合平面假定，正应力大体上呈直线分布。为计算方便，力和变形仍按材料力学计算，然后适当修正。</strong>（一般<strong>内力计算</strong>是：将总力矩的85%按材料力学的方法计算墙肢弯矩及轴力，将总力矩的15%按墙肢的刚度进行分配。<strong>位移的计算</strong>：按照整体墙计算，不过考虑到洞口削弱墙体刚度，最终结果要放大20%）</li><li><strong>联肢墙</strong><br>定义：当剪力墙沿竖向开有一列或多列较大的洞口时，由于洞口较大，剪力墙截面的整体性已被破坏，剪力墙的截面变形已不再符合平截面假设。这时剪力墙成为由一系列连梁约束的墙肢所组成的联肢墙。<br>受力特征：洞口开得比较大，截面的整体性已经破坏，<strong>横截面上正应力的分布远不是遵循沿一根直线的规律。<strong>但墙肢的线刚度比同列两孔间所形成的连梁的线刚度大得多，每根连梁中部有反弯点，各墙肢单独弯曲作用较为显著，但仅在个别或少数层墙肢出现反弯点。<strong>其变形曲线与整体小开口墙相近，仍以弯曲变形为主</strong>，内力计算宜采用连续化方法，例如</strong>连续连杆法</strong>。<blockquote><p>连续连杆法：<br><strong>基本假定</strong>：<br>1. 连梁反弯点位于跨中，连梁的作用可以用沿高度 均匀分布的连续弹性薄片代替。<br>2. 各墙肢的刚度相差不过分悬殊，因而变形曲线相似。<br>3. 连梁和墙肢考虑弯曲和剪切变形，墙肢还应考虑轴向变形的影响。<br>4. 各墙肢、连梁截面尺寸、材料强度及层高沿剪力墙全高相同。<br><strong>基本原理</strong>：运用力法原理，将连梁中点切开，去掉多余约束，建立静定体系。切开后连杆剪力是多余未知力，是一个连续函数。由切开处的变形协调条件建立连杆剪力的微分方程，求解微分方程即得连杆剪力 。将层高范围内的各点剪力积分还原成一根连梁的剪力。各层连梁中点剪力求出后，所有墙肢及连梁内力都可相继求出。</p></blockquote></li><li><strong>壁式框架</strong><br>定义：当剪力墙的洞口尺寸较大，墙肢宽度较小，连梁的线刚度接近于墙肢的线刚度时，剪力墙的受力性能已接近于框架，这种剪力墙称为壁式框架。<br>受力特征：洞口开得比联肢剪力墙更宽，墙肢宽度较小，墙肢与连梁刚度接近时，墙肢明显出现局部弯矩，在许多楼层有反弯点。剪力墙的内力分布接近框架。壁式框架实质是介于剪力墙和框架之间的一种过渡形式，它的变形已很接近剪切型。只不过壁柱和壁梁都较宽，因而在梁柱交接区形成不产生变形的刚域。</li></ol><h3 id="框架剪力墙结构内力计算"><a class="markdownIt-Anchor" href="#框架剪力墙结构内力计算"></a> 框架剪力墙结构内力计算</h3><div class="pdf-container" data-target="框架剪力墙结构内力计算.pdf" data-height="500px"></div><h3 id="双向板计算"><a class="markdownIt-Anchor" href="#双向板计算"></a> 双向板计算</h3><p>对于双向板的设计，有<strong>弹性设计</strong>和<strong>塑性设计</strong>两种。对于弹性设计，是通过查表得出弯矩设计值，书上也容易理解。对于塑性设计，书上采用了<strong>塑性铰线法</strong>，通过一系列推到，得到荷载P作用时，板的弯矩（书上表述为<strong>承载力</strong>，尚有不妥，应该为<strong>内力</strong>更好），然后配筋设计了。</p><div align="center"><img src="/2023/10/05/Study/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/双向板塑性设计.jpg" width="90%"></div><div align="center"><img src="/2023/10/05/Study/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/双向板塑性设计计算公式.jpg" width="80%"></div><p>从中也可以发现，所谓弹性设计、塑性设计，归纳起来就是<strong>以何种状态的抗力去抵抗该状态下的效应就是何种设计。</strong></p><h4 id="何为单向板与双向板"><a class="markdownIt-Anchor" href="#何为单向板与双向板"></a> 何为单向板与双向板？</h4><p>在学习《混凝土结构基本原理》之初，对于单向板，我们是按照长边/短边大于2（具体分为大于等于3和介于2-3之间）的原则来判断的。久而久之容易形成刻板印象，只通过边长比值来判断，这是不可取的。（见《混凝土》下册P30）<br>而实际上单向板和双向板定义：只在一个方向弯曲或主要在一个方向弯曲的板称为单向板；在两个方向弯曲且不能忽略任一方向弯曲的板称为双向板。</p><h3 id="应力应变-内力与位移之间关系"><a class="markdownIt-Anchor" href="#应力应变-内力与位移之间关系"></a> 应力应变、内力与位移之间关系</h3><p>应力与应变之间关系：<br>有应力不一定有应变（这个命题本身不是很严谨）比如三个方向应力取值得当可以使得某一方向无应变。<br>有应变不一定有应力，比如静定结构由于温度差异产生的应变。<br>内力和位移之间联系：<br>有内力不一定有位移。比如超静定结构中，由于温度变形受到限制而产生内力，但无位移。<br>有位移不一定有内力。比如静定结构支座位移并不产生内力。<br>关于<strong>位移和变形</strong>的区别，可以参考如下：</p><div align="center"><img src="/2023/10/05/Study/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/位移、变形的区别.png" width="90%"></div>]]></content>
      
      
      <categories>
          
          <category> 结构设计学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="/2023/10/05/Study/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/10/05/Study/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="个人博客"><a class="markdownIt-Anchor" href="#个人博客"></a> 个人博客</h2><h3 id="搭建过程"><a class="markdownIt-Anchor" href="#搭建过程"></a> 搭建过程</h3><ol><li><p>安装<a href="https://nodejs.org/en">Nodejs</a>,这里选择<code>LTS</code>版本，安装好后，运行如下命令(建议使用以管理员方式运行,例如将git bash设置为以管理员方式打开，我是选择始终以管理方式运行git bash)，检查nodejs安装是否成功。<a href="https://git-scm.com/"><strong>Git下载</strong></a>,建议装在系统盘(例如C盘)。</p><span id="more"></span><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查nodejs是否安装成功</span></span><br><span class="line"><span class="keyword">node</span> <span class="title">-v</span></span><br><span class="line">npm -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看npm下载的全局保存目录(prefix)和缓存位置(cache)</span></span><br><span class="line"><span class="comment"># 如果在C盘，可以换到D盘某个位置，例如就在Nodejs安装路径下新建`node_global`和`node_cache`两个文件夹。</span></span><br><span class="line"><span class="comment"># 然后更改`Nodejs安装路径\node_modules\npm`下的npmrc和.npmrc文件，加上上述两个文件夹的路径。</span></span><br><span class="line">npm config ls  </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>将Nodejs中的全局保存目录（保存下载的库）和<code>Nodejs安装路径\node_modules\npm</code>放到系统变量中的Path下，如下图所示。</p><div align="center"><img src="/2023/10/05/Study/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/nodejs添加环境变量.jpg" width="70%"></div><blockquote><p>其中全局保存目录是为了后面<code>hexo</code>命令能顺利运行，而<code>...\npm</code>文件夹则是为了npm能顺利运行。</p></blockquote></li><li><p>然后在博客文件夹（必须是新文件夹）(这里以<code>D:\Blog</code>举例),git bash,运行如下命令：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-<span class="keyword">cli</span> <span class="meta">#(下载到全局保存目录)</span></span><br><span class="line"></span><br><span class="line">hexo init <span class="meta"># 博客初始化</span></span><br><span class="line"></span><br><span class="line">npm install hexo-<span class="keyword">cli</span>  <span class="meta">#下载hexo到`D:\Blog\node_modules`</span></span><br><span class="line"></span><br><span class="line">hexo -v <span class="meta"># 若成功显示版本，则表示hexo安装成功了。</span></span><br><span class="line"></span><br><span class="line">hexo g  </span><br><span class="line"></span><br><span class="line">hexo s  <span class="meta"># 然后再本地打开即可。</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 这样博客就初步搭建完成了。</span></span><br></pre></td></tr></table></figure></li><li><p>可以运行<code>hexo new  xxx.md</code>来生成文章，然后运行<code>hexo g</code>，等待部署到github上。</p></li><li><p>参考：<a href="https://blog.csdn.net/m0_48121128/article/details/132380427"><strong>完成hexo到GitHub的部署</strong></a>，这里要注意，在博客目录下config.yaml修改时（如下）：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">   type:</span> git</span><br><span class="line"><span class="symbol">   repo:</span> git@github.com:Yourname/Yourname.github.io.git   <span class="meta"># 这里不要用https: 链接，否则后面部署时傻里傻气的。</span></span><br><span class="line"><span class="symbol">   branch:</span> main  <span class="meta">#这里分支要选择好，main是默认的，可以新建分支(比如source)，但要对应github-pages那里生成的分支，如下图所示。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><div align="center"><img src="/2023/10/05/Study/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/github%20pages生成选择分支.jpg" width="70%"></div></li><li><p>再运行<code>npm install hexo-deployer-git --save</code>（否则<code>hexo d</code>无效，无法完成部署）。</p></li></ol><h3 id="搭建过程疑问"><a class="markdownIt-Anchor" href="#搭建过程疑问"></a> 搭建过程疑问</h3><ol><li><p>最开始搭建一个最简单的网站主要参考一下几条博客。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>blog.csdn.net<span class="regexp">/sinat_37781304/</span>article<span class="regexp">/details/</span><span class="number">82729029</span></span><br></pre></td></tr></table></figure></li><li><p>hexo 如何新建一篇文章。<!--more--></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost blog]# hexo <span class="keyword">new</span> <span class="string">&quot;如何在hexo上创建一篇文章&quot;</span></span><br><span class="line">...</span><br><span class="line">INFO  Created: <span class="regexp">/blog/</span><span class="keyword">source</span><span class="regexp">/_posts/</span>如何在hexo上创建一篇文章.md</span><br></pre></td></tr></table></figure><p>这个缺点是他只能在<code>...source/_posts</code>下生成，没法完成自己的分类，还是推荐在<code>VSCode</code>中创建新文章。</p></li><li><p>hexo 显示无法连接到 <code>github</code>.</p><blockquote><p>fatal: unable to access '<a href="https://github.com/Hushuangjun/Hushuangjun.github.io.git">https://github.com/Hushuangjun/Hushuangjun.github.io.git</a></p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>blog.csdn.net<span class="regexp">/weixin_46087812/</span>article<span class="regexp">/details/</span><span class="number">124575202</span></span><br></pre></td></tr></table></figure><p>如果在搭建过程中，采用<code>repo: git@github.com:Yourname/Yourname.github.io.git</code>,则不会报这个错。</p></li><li><p>markdown中插入本地图片不显示</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>www.cnblogs.com<span class="regexp">/koo070/</span>p/<span class="number">16548228</span>.html</span><br></pre></td></tr></table></figure></li><li><p>怎么实现图片等比例缩放，或者指定高度，并且居中、左、右？</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>zhuanlan.zhihu.com<span class="regexp">/p/</span><span class="number">139007418</span></span><br></pre></td></tr></table></figure></li><li><p>为啥hexo-pdf按操作弄完之后，点进去直接下载却不显示pdf？</p><blockquote><p>因为我们<strong>idm</strong>插件接管了那个命令，<strong>只要把浏览器的idm插件关闭即可</strong>。</p></blockquote></li><li><p>为啥每次<code>hexo d</code>后，在<code>settings-pages</code>那里都要重新配置<code>custom domain</code>?</p><blockquote><p>为避免这个麻烦，可以在博客目录下<code>source</code>文件夹下新建<code>CNAME</code>,内容为需要绑定的域名(我的为<code>husj0711.top</code>).<br>参考<a href="https://blog.csdn.net/weixin_49175501/article/details/128705141">解决方案</a></p></blockquote></li><li><p>为啥博客在本地(localhost:4000)查看可以，网络打开排版很乱。<br><code>Shift + F5</code>强制刷新页面即可。</p></li><li><p>在hexo-Next如何显示latex公式？<br>多翻阅<a href="https://theme-next.js.org/docs/third-party-services/math-equations.html">官方文档</a>,里面有详细的步骤，这里选用<strong>katex</strong>，大致步骤简述如下：</p><ol><li>卸载hexo的插件<code>hexo-math</code>和<code>hexo-katex</code>，否则会与Next主题自带的渲染插件冲突；</li></ol><blockquote><p>npm uninstall hexo-math<br>npm uninstall hexo-katex</p></blockquote><ol start="2"><li>在主题配置文件中将Katex设置为渲染引擎；</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">katex:</span></span><br><span class="line">   <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ol start="3"><li>卸载原始渲染引擎<code>hexo-renderer-marked</code>，下载新的渲染引擎<code>npm i hexo-renderer-markdown-it-plus</code>或者<code>npm i hexo-renderer-markdown-it</code>.</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">npm</span> un hexo-renderer-marked</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">npm</span> i hexo-renderer-markdown-<span class="literal">it</span>-plus</span><br><span class="line"><span class="keyword">or</span></span><br><span class="line">$ <span class="built_in">npm</span> i hexo-renderer-markdown-<span class="literal">it</span></span><br></pre></td></tr></table></figure></li><li><p>遇到katex渲染的公式不显示怎么办？<br>首先，在next主题配置文件<code>_config.yml</code>把katex的<code>enable</code>开关给关掉，然后再运行<code>hexo clean</code>,随后再把katex的<code>enable</code>打开（改成true），最后运行<code>hexo g &amp;&amp; hexo d</code>即可。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>力学基础和专业基础(持续更新)</title>
      <link href="/2023/10/05/Study/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/10/05/Study/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="材料力学"><a class="markdownIt-Anchor" href="#材料力学"></a> 材料力学</h2><span id="more"></span><ol><li><p>最近学了拉压、扭的部分，大致思路都是<strong>强度-刚度-应变能</strong>，公式也很类似。下面分享几个比较有意思的点：<br>第一个是<strong>小变形放大图</strong>，常用来解决超静定问题，依靠<strong>平衡方程</strong>和<strong>变形协调方程</strong>，再加上本构方程。这里的<strong>变形协调</strong>其实就是后面<strong>力法方程的本质</strong>，可以说是埋下伏笔了。</p></li><li><p>第二个是<strong>功互等定理</strong>和<strong>位移互等定理</strong>，在材料力学中只是当作附加部分讲了讲，并没有涉及其本质，具体推导可以参见 <strong>《结构力学》（龙驭球）第五章最后一节</strong>，用虚功原理予以解释，此外，那里还介绍了两个互等定理。注意：上述四个互等定理只适用于<strong>线性变形体系</strong>。</p></li><li><p><strong>剪应力互等定理</strong>新的理解<br>详细可以参考一下这篇文章。感觉与以前理解不同的地方在于：取出来的单元体实际上六个面均有力，每个面有两个方向的切应力和一个正应力，相对的面上应力相等。（他给出的解释是单元体足够小，可以看作一个点，故相对的两个面力相等）</p> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>www.zhihu.com<span class="regexp">/question/</span><span class="number">21070058</span></span><br></pre></td></tr></table></figure></li><li><p>非对称纯弯曲梁的正应力（《材料力学》下册1-1节）<br>推导得到了<strong>广义弯曲正应力</strong>，有一个印象即可。对于<strong>非对称弯曲</strong>，应该是指梁不具有对称平面，或者梁具有对称平面，但外力不作用在该平面内，梁将发生非对称弯曲。</p></li><li><p>开口薄壁截面梁的剪应力流和弯曲中心<br><strong>截面剪应力流的方向确定</strong>：(简单的根据：与剪力平行的截面上剪应力流与剪力平行，例如矩形截面，工字形截面的腹板等。)</p><ol><li>根据截面弯矩和中性轴确定拉压应力；(方便下一步由正应力合成轴力)</li><li>切开构件，取隔离体，根据隔离体轴力平衡，非自由面取切应力(一般只有3个非自由面，其中有两个是前后轴力方向，另一个面取剪应力来平衡)，然后再根据剪应力互等定理确定前后两个非自由面上剪应力方向。</li></ol><div class="pdf-container" data-target="弯曲中心.pdf" data-height="500px"></div><p>而弯曲中心的确定方法见《材料力学合并文档》P252.核心就是<strong>截面上剪应力合成到某点，只有力而无力偶，该点即为弯曲中心</strong>。<br>重点是<strong>弯曲中心（剪切中心）的作用</strong>：非对称截面梁发生平面弯曲的条件：<strong>外力必须作用在通过弯曲中心且平行于形心主惯性平面（或与之重合）的平面内。</strong></p></li></ol><h2 id="结构力学"><a class="markdownIt-Anchor" href="#结构力学"></a> 结构力学</h2><h3 id="单自由度结构自由振动自振频率的求解"><a class="markdownIt-Anchor" href="#单自由度结构自由振动自振频率的求解"></a> 单自由度结构自由振动自振频率的求解</h3><p>今天复习了结构动力学基础中一个重要问题——单自由度结构体系自由振动自振频率的求解。困扰了将近一年的问题今天终于搞定了。顺便复习了<strong>科氏加速度</strong>等几个概念，具体参见《理论力学》P190.</p><div class="pdf-container" data-target="单自由度结构体系自振频率求解.pdf" data-height="500px"></div><h3 id="虚功原理-虚力原理与虚位移原理辨析"><a class="markdownIt-Anchor" href="#虚功原理-虚力原理与虚位移原理辨析"></a> 虚功原理、虚力原理与虚位移原理辨析</h3><div class="pdf-container" data-target="虚功原理、虚力原理与虚位移原理.pdf" data-height="500px"></div><p>根据上述资料，可知虚功原理表述为：<br>如果<strong>力系满足平衡方程，变形状态满足协调方程</strong>，则虚功方程（下式）成立。</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>∑</mo><msub><mi>F</mi><mi>P</mi></msub><mi mathvariant="normal">Δ</mi><mo>+</mo><mo>∑</mo><msub><mi>F</mi><mrow><mi>R</mi><mi>K</mi></mrow></msub><msub><mi>C</mi><mi>K</mi></msub><mo>=</mo><mo>∑</mo><msubsup><mo>∫</mo><mi>A</mi><mi>B</mi></msubsup><mo stretchy="false">(</mo><mi>M</mi><mi>k</mi><mo>+</mo><msub><mi>F</mi><mi>N</mi></msub><mi>ε</mi><mo>+</mo><msub><mi>F</mi><mi>Q</mi></msub><msub><mi>γ</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mi>d</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\sum F _ { P } \Delta + \sum F _ { R K } C _ { K } = \sum \int _ { A } ^ { B } ( Mk+ F _ { N } \varepsilon + F _ { Q } \gamma _ { 0 } ) d s </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">Δ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.5031810000000005em;vertical-align:-0.9119499999999999em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5912310000000005em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span style="top:-3.812900000000001em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">ε</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">Q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span></span></span></span></span></p><p><strong>然后，单独一个虚功方程只是必要条件，而不是充分条件。</strong><br>由此引出一个想法：能否将虚功原理及其虚功方程(上式)加以改造，使改造后的“虚功型方程”（指：用虚功形式表示的方程）成为变形协调方程或力系平衡方程的充分必要条件呢？于是，就产生了下列两个“虚功型原理”一虚力原理和虚位移原理。<br><strong>虚力原理</strong>：<br><strong>在虚设力系满足平衡方程且具有任意性的前提下</strong>，如果虚力方程（下图）成立，则待检查的变形状态必满足变形协调方程。反之，在上述前提下，如果已知该变形状态满足变形协调方程，则虚力方程必成立。综合起来，在上述前提下，虚力方程是变形协调方程的充分必要条件。</p><div align="center"><img src="/2023/10/05/Study/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/虚力方程.jpg" width="70%"></div><p><strong>虚位移原理</strong>：<br><strong>在虚设变形状态满足变形协调方程并具有任意性的前提下</strong>，如果虚位移方程(下式)成立，则待检查的力系必满足平衡方程。反之，在上述前提下，如果已知该力系满足平衡方程，则虚位移方程必成立。综合起来，在上述前提下，虚位移方程是力系平衡方程的充分必要条件。</p><div align="center"><img src="/2023/10/05/Study/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/虚位移方程.jpg" width="70%"></div><h3 id="结构对称性探究"><a class="markdownIt-Anchor" href="#结构对称性探究"></a> 结构对称性探究</h3><div align="center"><img src="/2023/10/05/Study/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/结构力学对称性探究-1.JPG" width="70%"></div><div align="center"><img src="/2023/10/05/Study/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/结构力学对称性探究-2.JPG" width="70%"></div><p>正是由于上述结论，可将奇/偶跨对称结构简化，<strong>简化的要求是与原结构等效，表现为力和变形条件。</strong><br>值得注意的是，**对称轴处的荷载要减半，当然最终结果加和时，对称轴处相当于加了两次，合理的。**可参考下面这篇文章：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文章一：https:<span class="regexp">//</span>zhuanlan.zhihu.com<span class="regexp">/p/</span><span class="number">576399081</span></span><br><span class="line">文章二：https:<span class="regexp">//</span>zhuanlan.zhihu.com<span class="regexp">/p/</span><span class="number">147244195</span></span><br></pre></td></tr></table></figure><h4 id="对称边界与反对称边界位移条件"><a class="markdownIt-Anchor" href="#对称边界与反对称边界位移条件"></a> 对称边界与反对称边界位移条件</h4><p>最近学习了<strong>水哥ansys初级教程</strong>，其中谈到<strong>对称边界和反对称边界位移条件时</strong>时，有：</p><ol><li>受对称载荷作用则对称面上的位移条件为<ol><li>垂直于对称面的移动位移分量为零。</li><li>绕平行于对称面的两相互垂直的轴的转动位移分量均为零。</li></ol></li><li>受反对称载荷作用则对称面上的位移条件为<ol><li>平行于对称面的移动位移分量为零；</li><li>绕方向矢量垂直于对称面的轴的转动位移分量为零。</li></ol></li></ol><h3 id="结构矩阵分析-平衡-几何互伴定理"><a class="markdownIt-Anchor" href="#结构矩阵分析-平衡-几何互伴定理"></a> 结构矩阵分析-“平衡-几何”互伴定理</h3><p>定理证明：</p><ul><li>龙驭球《结构力学》下册 第14章</li></ul><p>定理的运用，以老师留的习题为例：</p><div class="pdf-container" data-target="结构矩阵分析-平衡几何定理.pdf" data-height="500px"></div><h3 id="结构刚度矩阵推导的两种方法"><a class="markdownIt-Anchor" href="#结构刚度矩阵推导的两种方法"></a> 结构刚度矩阵推导的两种方法</h3><div class="pdf-container" data-target="结构刚度矩阵推导的两种方法.pdf" data-height="500px"></div><h2 id="土力学"><a class="markdownIt-Anchor" href="#土力学"></a> 土力学</h2><p>由于较少从事这方面研究，目前待更新！！！</p><h2 id="混凝土结构基本原理"><a class="markdownIt-Anchor" href="#混凝土结构基本原理"></a> 混凝土结构基本原理</h2><h3 id="钢筋混凝土受扭构件承载力公式推导的两种方法"><a class="markdownIt-Anchor" href="#钢筋混凝土受扭构件承载力公式推导的两种方法"></a> 钢筋混凝土受扭构件承载力公式推导的两种方法</h3><p>此文章写于大三下学期，目前来看，这两种方法的本质相同，第一种根据q相同求得，第二种根据Tu相同求得，但又有</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>T</mi><mi>u</mi></msub><mo>=</mo><mn>2</mn><mi>q</mi><msub><mi>A</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{u} = 2qA_{cor}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>故其本质相同。</p><div class="pdf-container" data-target="钢筋混凝土受扭构件承载力.pdf" data-height="500px"></div><h2 id="钢结构基本原理"><a class="markdownIt-Anchor" href="#钢结构基本原理"></a> 钢结构基本原理</h2><h3 id="稳定性"><a class="markdownIt-Anchor" href="#稳定性"></a> 稳定性</h3><h4 id="规范上对于轴心受压-受弯及压弯构件的宽厚比限值是从何得来的"><a class="markdownIt-Anchor" href="#规范上对于轴心受压-受弯及压弯构件的宽厚比限值是从何得来的"></a> 规范上对于轴心受压、受弯及压弯构件的宽厚比限值是从何得来的？</h4><p>宽厚比限值的根本目的是为了防止局部失稳先于整体失稳。由此，规范采用等稳定性原则，即板件屈曲应力不小于构件屈曲应力。</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>σ</mi><mrow><mi>c</mi><mi>r</mi><mi>x</mi></mrow></msub><mo>≥</mo><msub><mi>σ</mi><mrow><mi>c</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\sigma_{crx}\geq \sigma _{cr}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>同时，根据<strong>以何种状态下（例如弹性）抗力抵抗该种状态下效应即为该种状态设计</strong>，故当板件弹性屈曲应力不小于构件弹性屈曲应力，为<strong>弹性设计</strong>。</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><msub><mi>b</mi><mn>1</mn></msub><mi>t</mi></mfrac><mo>≤</mo><mn>15</mn><msub><mi>ε</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\frac{b_{1}}{t}\leq 15 \varepsilon _{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord"><span class="mord mathnormal">ε</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>这些天(2023-10-17)恰好在学习冷弯薄壁型钢的设计，这里举例如下：</p><div align="center"><img src="/2023/10/05/Study/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/冷弯薄壁型钢整体屈曲与局部屈曲关系.jpg" width="70%"></div><h2 id="土木工程施工"><a class="markdownIt-Anchor" href="#土木工程施工"></a> 土木工程施工</h2><h3 id="土方工程"><a class="markdownIt-Anchor" href="#土方工程"></a> 土方工程</h3><h4 id="基坑支护"><a class="markdownIt-Anchor" href="#基坑支护"></a> 基坑支护</h4><p>基坑支护包括一般基坑支护和深基坑支护。<br>深基坑支护方法有：</p><ol><li><strong>水泥土挡墙式支护结构</strong>：采用深层搅拌机就地将土和输入的水泥浆强行搅拌，形成连续搭接的水泥土柱状加固体挡墙。</li><li><strong>排桩与板墙式支护结构</strong>：开挖前在基坑周围设置砼灌注桩或钢板桩，桩的排列有间隔式、双排式和连续式，桩顶设置砼连系梁或锚桩、拉杆。</li><li><strong>土钉墙支护</strong>：在天然土体通过钻孔、插筋、注浆来设置土钉(亦称砂浆锚杆)并与喷射砼面板相结合，形成类似重力挡墙的土钉墙，以抵抗墙后的土压力，保持开挖面的稳定。</li><li><strong>土层锚杆支护结构</strong>：在深基础立壁上钻孔，并达到一定深度，然后在孔内放入钢筋等材料，灌入泥浆或化学浆液，使其与土层结合成为抗拉（拔）力强的锚杆，将立壁土体侧压力传至稳定土层。<blockquote><p>在实际工程中，其实上述某些方法可组合使用，例如挡土灌注桩（排桩）+土层锚杆等。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 结构设计学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 材料力学 </tag>
            
            <tag> 结构力学 </tag>
            
            <tag> 土力学 </tag>
            
            <tag> 混凝土结构基本原理 </tag>
            
            <tag> 钢结构基本原理 </tag>
            
            <tag> 土木工程施工 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学生活</title>
      <link href="/2023/05/05/Life/%E6%9C%AC%E7%A7%91%E7%94%9F%E6%B4%BB/"/>
      <url>/2023/05/05/Life/%E6%9C%AC%E7%A7%91%E7%94%9F%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="五一假期"><a class="markdownIt-Anchor" href="#五一假期"></a> 五一假期</h2><p>这几天都在学校学习，认真看了高层建筑这本书，感觉讲的比较浅显，如果不看具体例子不容易理解。<span id="more"></span></p><p>5.1号还去网球场打了会网球，感觉有一点点进步，继续加油。</p><p>高中学姐请我出来吃饭，转眼间三年快过去了，真快呀，还记得刚来青岛时学长学姐们欢迎我们的时候，有时候真挺不舍的，但天下没有不散的筵席，今日的分别时为了他日更好的相见，加油加油！</p><p>祝学姐毕业快乐！工作顺利！<br>接下来我也要忙着复习和准备着保研啦！</p><h2 id="钢结构设计后休闲时光"><a class="markdownIt-Anchor" href="#钢结构设计后休闲时光"></a> 钢结构设计后休闲时光</h2><p>下面是两周完成的<strong>钢结构设计</strong>，还可以吧！</p><div class="pdf-container" data-target="钢结构课程设计.pdf" data-height="500px"></div><p>搞完设计感觉自己有点懒惰，夏令营那些东西还没弄完呢，加上自己又碰上了毛囊炎，真该死呀！振作起来振作起来！！！<br>最近睡得也比较晚，精神状态极差，需要尽快调整过来。今晚争取把个人自述科研经历部分写完。</p><h2 id="2023-12-6有感"><a class="markdownIt-Anchor" href="#2023-12-6有感"></a> 2023-12-6有感</h2><p>今天胖哥生日，一起去烤羊腿店吃饭，鸡哥输我一餐饭，顺便在此请了。大学四年如梦幻一般，一下子接近尾声了，大学难得遇到如此好的室友，幸甚至哉！待毕业事宜弄得差不多时，以我浅薄的知识储备为各室友赋诗一首，聊表心意。</p>]]></content>
      
      
      <categories>
          
          <category> 日常记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
