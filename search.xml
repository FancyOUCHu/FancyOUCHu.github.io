<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>破局</title>
      <link href="/2023/11/13/%E5%AD%A6%E4%B9%A0/%E7%A0%B4%E5%B1%80/"/>
      <url>/2023/11/13/%E5%AD%A6%E4%B9%A0/%E7%A0%B4%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="c语言"><a class="markdownIt-Anchor" href="#c语言"></a> C语言</h2><span id="more"></span><h3 id="基本数据类型与运算"><a class="markdownIt-Anchor" href="#基本数据类型与运算"></a> 基本数据类型与运算</h3><ol><li>getchar()函数<ol><li>**只能从键盘缓冲区接收字符，一次只能接收一个字符。**如果之前有<code>scanf(&quot;%c&quot;,&amp;str);</code>类似语句，回车键<code>\n</code>也被会当作一个字符留在键盘缓冲区。如果不是char类型倒不要紧。</li><li>如果之前没有用scanf()接收过字符,那么使用getchar()函数时，需要先键入字符，<strong>按enter键后</strong>，键入的字符(串)进入缓冲区，然后getchar会从中取一个字符(按输入的顺序)，以后每次调用getchar()都会从缓冲区接收一个字符，直至缓冲区字符用完，在重复以上步骤。</li><li>典型例题：加密电文，所有大小写英文字母＋4(ASCII码) 循环，其余字符不变。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> str;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> ( ; (str=getchar()) != <span class="string">&#x27;\n&#x27;</span> ; )&#123;</span><br><span class="line">      <span class="keyword">if</span> (str&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp; str &lt;= <span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>+(str+<span class="number">4</span>-<span class="string">&#x27;a&#x27;</span>)%<span class="number">26</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (str &gt;= <span class="string">&#x27;A&#x27;</span>&amp;&amp; str &lt;= <span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span>+(str+<span class="number">4</span>-<span class="string">&#x27;A&#x27;</span>)%<span class="number">26</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(str);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>关于<code>str = '!'; 48 &lt;= str &lt;= 57</code>为啥总是得到1？<br>因为<code>&lt;=</code>的结合性是自左向右，故先会计算<code>48 &lt;= str</code>,此时str = ‘!’,ASCII值是33，故返回值是1.再计算<code>1 &lt;= 57</code>,返回值是1.由此可以看出学了python之后，再学C感觉步骤很啰嗦。但正是因为步骤啰嗦（分类齐全，条理清晰），故C速度很快。</li></ol><h3 id="选择结构程序设计"><a class="markdownIt-Anchor" href="#选择结构程序设计"></a> 选择结构程序设计</h3><ol><li>注意<code>if - else if - else</code>如果<strong>没有大括号就遵循就近原则</strong>，所以写的时候尽量带上大括号。例如:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">1</span>,b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">      <span class="keyword">if</span> (b &gt; c)</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,b);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>最后结果什么也不会输出！！因为其相当于<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a&gt;b)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> (b &gt; c)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,b);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>switch</code>选择语句：注意表达式A的值必须为整型数据（当然包括字符型），而a、b…必须是常量或者常量表达式。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式A)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">case</span> a:  表达式<span class="number">1</span>  ; <span class="keyword">break</span>;  <span class="comment">//必须加上break，否则后续case会一直执行，直到break或者全部读完。</span></span><br><span class="line">   <span class="keyword">case</span> b:  表达式<span class="number">2</span>  ; <span class="keyword">break</span>;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">default</span>:  表达式n ; <span class="keyword">break</span>;  <span class="comment">// 可以不用break,反正都结束了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>C语言中唯一一个三目运算符：条件运算符(<code>? :</code>)，对应表达式就是条件表达式:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a &gt; b ? a:b</span><br><span class="line"><span class="comment">//条件语句</span></span><br><span class="line">c = a &gt; b ? a:b ;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">if</span> (a&gt;b)&#123;</span><br><span class="line">   c = a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">   c = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="循环结构程序设计"><a class="markdownIt-Anchor" href="#循环结构程序设计"></a> 循环结构程序设计</h3><ol><li><code>while</code>循环：表达式为真，进入循环，直至表达式为假或者<code>break;</code>跳出循环.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line">   语句<span class="number">1</span>;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>do while</code>循环：特别注意while后面还有个分号<code>;</code>.  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">   语句<span class="number">1</span>；</span><br><span class="line">   ...</span><br><span class="line">&#125; <span class="keyword">while</span> (表达式) ;  </span><br></pre></td></tr></table></figure></li><li><code>for</code>循环:其中表达式1和3可以为<strong>逗号表达式</strong>，表达式2是判断条件，为真的话继续。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (表达式<span class="number">1</span>; 表达式<span class="number">2</span>; 表达式<span class="number">3</span>) </span><br><span class="line">&#123;</span><br><span class="line">   语句<span class="number">1</span>;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于:</span></span><br><span class="line">表达式<span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (表达式<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">   语句<span class="number">1</span>;</span><br><span class="line">   ...</span><br><span class="line">   表达式<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h3><ol><li>定义数组<blockquote><p>一维数组定义：(二维数组同理)<br>类型符  数组名[常量表达式]</p></blockquote>特别注意是<strong>常量表达式</strong>，不能是<strong>变量</strong>。</li><li>数组名的值数组第一个元素的地址，相当于是一个常量，是不能被赋值的。因此下列数组初始化是错误的:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&quot;string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure></li><li>如何直接输出字符串？或者输入字符串?<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出, str是已定义的字符串数组</span></span><br><span class="line"><span class="built_in">printf</span>(&quot;%s&quot;,str);</span><br><span class="line"><span class="built_in">put</span>(str);  <span class="comment">// 特别注意put不能输出多个字符串,而printf()可以。</span></span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="built_in">scanf</span>(&quot;%s&quot;,str); <span class="comment">//由于str的值就是数组第一个元素的地址，故不需要取值符`&amp;`.同时，输入的字符串大小应不大于定义的字符数组的大小。</span></span><br><span class="line"><span class="built_in">get</span>(str); <span class="comment">//同理，一次只能接收一个字符串数组。</span></span><br></pre></td></tr></table></figure></li><li>字符串处理函数</li></ol><table><thead><tr><th>函数名称</th><th>作用</th><th>返回值</th></tr></thead><tbody><tr><td>puts(str)</td><td>输出<strong>单个</strong>字符串</td><td>-</td></tr><tr><td>gets(str)</td><td>输入<strong>单个</strong>字符串</td><td>-</td></tr><tr><td>strlen(str)</td><td>测量字符串的长度</td><td>返回字符串的长度(不包括<code>\0</code>)</td></tr><tr><td><strong>size_of(str)</strong></td><td>测量字符串的内存大小</td><td>返回字符串的内存大小</td></tr><tr><td>strcat(str1,str2)</td><td>将<strong>字符串2</strong>接到<strong>字符串1</strong>后面</td><td>返回的是字符串1的地址</td></tr><tr><td>strcpy(str1,str2)</td><td>将字符串2(包括<code>\0</code>)复制到字符串1中</td><td>返回的是字符串1的地址</td></tr><tr><td>strncpy(str1,str2)</td><td>将字符串2前n个字符（n不多于字符串长度）复制到字符串1中</td><td>返回的是字符串1的地址</td></tr><tr><td>strlwr(str)</td><td>将字符串中大小写字母变成<strong>小写字母</strong></td><td>不返回任何值，对于字符串是原位修改</td></tr><tr><td>strupr(str)</td><td>将字符串中大小写字母变成<strong>大写字母</strong></td><td>不返回任何值，对于字符串是原位修改</td></tr><tr><td>strcpm(str1,str2)</td><td>依次比较str1和str2中字符的大小，按照ASCII码比较</td><td>str1==str2,则返回0；str1 &gt; str2,则返回一个正整数;str1 &lt; str2，则返回一个负整数.</td></tr></tbody></table><h3 id="指针与数组"><a class="markdownIt-Anchor" href="#指针与数组"></a> 指针与数组</h3><ol><li>指针变量也是一个变量，占用的字节大小取决于其<strong>存储的内存地址</strong>的大小，而常说的指针=“储存的内存的地址”。（也是我们常说的变量，但变量只有我们和编译器知道，编译器在编译时，变量名和内存地址有一个一一对应的关系）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明指针变量，&amp;为取地址运算符</span></span><br><span class="line"><span class="type">char</span> *pa = &amp;a;   <span class="comment">//用char是因为指针变量所储存的内存地址所对应的数据类型是char.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,pa); <span class="comment">//打印内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*pa); <span class="comment">//打印变量a的值，这里*是取值运算符。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><strong>数组名==指针变量</strong>，数组名储藏着数组第一个元素的地址，对于<strong>字符数据类型</strong>，可以直接用指针创建数组，下面代码演示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> *a = <span class="string">&quot;OUC&quot;</span>;  <span class="comment">//对于int等类型就行不通，还是得老老实实用数组的方式创建。</span></span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,a[i]);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>指针与数组的区别：指针变量是左值(lvalue)，可以修改的；而数组名是地址常量，不可以修改，故不是左值。代码如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> str[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">   <span class="type">int</span> *target = str;  </span><br><span class="line">   <span class="type">int</span> count  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (*target++ != <span class="number">3</span>)  <span class="comment">//此处必须用指针变量，不能用数组名。</span></span><br><span class="line">   &#123;</span><br><span class="line">      count++;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;总共有%d个数字\n&quot;</span>,count);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>指针数组和数组指针：指针数组是指数组元素全为指针的数组；数组指针是一个指针，它指向的是一个数组。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区分下列哪个是指针数组，哪个是数组指针</span></span><br><span class="line"><span class="type">int</span> *p1[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*p2)[<span class="number">5</span>];  <span class="comment">//int (*p)[5]就相当于int a[5]，a就是数组地址！！！ (区别于数组首地址，后面会讲到)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[ ]优先级大于*；虽然[]和()优先级一样，但结合性是从左到右，故第一个是指针数组，第二个是数组指针。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>关于数组指针还有一个坑，数组指针指向的是一个数组，而我们之前常用<code>int *p = temp;</code>(此处temp是一个已定义的整型数组)来将<code>指针指向数组</code>,但实际上，<strong>指针只是指向了数组第一个元素的地址</strong>。现在我们要想数组指针指向整个数组，需使用<code>int (*p)[5] = &amp;temp</code>;这里<code>&amp;temp</code>相当于将整个数组看作一个整体来看待的。举例如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> temp[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">   <span class="comment">// int (*p)[5] = temp;  //输出也可以，因为把数组当作整体给出地址还是数组首地址，但编译器会提醒。</span></span><br><span class="line">   <span class="type">int</span> (*p)[<span class="number">5</span>] = &amp;temp;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(*p + i));  <span class="comment">//数组指针终究是个指针，指向的是一个地址，故只需要写*p即可，不需下标当作数组。</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VSCode 系列教程</title>
      <link href="/2023/11/13/%E5%AD%A6%E4%B9%A0/VSCode%20%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
      <url>/2023/11/13/%E5%AD%A6%E4%B9%A0/VSCode%20%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="vscode"><a class="markdownIt-Anchor" href="#vscode"></a> VSCode</h2><h3 id="vscode配置cc"><a class="markdownIt-Anchor" href="#vscode配置cc"></a> VScode配置C/C++</h3><span id="more"></span><h4 id="初步配置"><a class="markdownIt-Anchor" href="#初步配置"></a> 初步配置</h4><ol><li>由于C语言是编译型语言，而vscode仅仅是一个代码编辑器，故需要先配置编译器，这里我选择mingw-w64的<a href="https://sourceforge.net/projects/mingw-w64/files/"><strong>gcc编译器</strong></a>。注意下载后需要将&quot;…\mingw64\bin&quot;放到环境变量（不放心的话系统和用户环境变量都添加上）。</li><li>然后在vscode上下载扩展插件(C/C++),这里要注意，尽量安装版本较老的，否则不会自动生成launch.json文件。如果实在没法自动生成，可自己配置，参考<a href="https://blog.csdn.net/m0_63702526/article/details/130136859">VSCode配置C/C++</a>等多篇文章.</li><li>配置好之后，可以运行C/C++源文件了，但发现：<strong>终端窗口在程序一运行完就立即消失了</strong>，于是上网查阅了各种办法，选择了两种运行方式：（具体见配置文件 <code>launch.json</code> 和<code>tasks.json</code>。当然，两者都是gcc编译的。）<ol><li>在外终端（C:\WINDOWS\system32\cmd.exe）运行可执行文件(.exe)。</li><li>在内终端(D:\Computer Softwares\Visual studio code\Codes..)(即项目所在地址，相当于直接git bash here) 运行可执行文件(.exe)。</li></ol></li><li>但是很快就发现一个问题，外终端运行时打印汉字会乱码，于是在<code>tasks.json</code>文件中增加<code>&quot;-fexec-charset=GBK&quot;</code>，但很快就发现，内终端运行时就乱码了。于是查阅<a href="https://blog.csdn.net/weixin_43439450/article/details/118331694"><strong>网上一些资料</strong></a>，进行如下操作即可实现内外终端均不会乱码。<ol><li>将cmd的编码（解码）方式由默认的<code>gbk</code>换成<code>utf-8</code>,具体参考<a href="https://blog.csdn.net/qq_43768851/article/details/123501124"><strong>如何更改cmd的编/解码格式</strong></a>.</li><li>将gcc的编/解码方式也换成<code>utf-8</code>,(这也是gcc默认的)，在<code>tasks.json</code>文件中增加<code>&quot;-finput-charset=UTF-8&quot;</code>,删掉原来的<code>&quot;-fexec-charset=GBK&quot;</code>.</li></ol></li><li>至此，就完成了VScode对C/C++的配置！<br>注意：<ol><li><strong>项目所在地址应为英文路径</strong>，否则编译器会报错。</li><li>配置好的<code>c_cpp_properties.json</code>、<code>lanuch.json</code>和<code>task.json</code>见<a href="https://pan.baidu.com/s/1PKbGVBoxTYaMnY56qU3W2w?pwd=8jda">链接</a>,提取码:8jda.将这三个文件放入<code>.vscode</code>文件夹下，即可完美运行<strong>C源文件</strong>，对于<strong>C++源文件</strong>目前还未测试。</li><li>对于多个C文件同时运行是不支持的，可能因为<strong>编译生成的程序名称还是以c源文件名称来命名的原因吧</strong>，可能要在task.json和launch.json文件下改。<ol><li>对的，task.json中args参数改动：：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;-g&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;file&#125;</span>&quot;</span>,</span><br><span class="line"><span class="string">&quot;-o&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;fileDirname&#125;</span>\\<span class="variable">$&#123;fileBasenameNoExtension&#125;</span>.exe&quot;</span>,</span><br><span class="line"></span><br><span class="line">改为:</span><br><span class="line"><span class="string">&quot;-g&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;workspaceFolder&#125;</span>\\*.c&quot;</span>,//c++代码就改这里后缀为.cpp</span><br><span class="line"><span class="string">&quot;-o&quot;</span>,</span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;workspaceFolder&#125;</span>\\<span class="variable">$&#123;workspaceRootFolderName&#125;</span>.exe&quot;</span>,</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>launch.json文件改动如下：</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;program&quot;</span>: <span class="string">&quot;<span class="subst">$&#123;fileDirname&#125;</span>\\<span class="subst">$&#123;fileBasenameNoExtension&#125;</span>.exe&quot;</span>,</span><br><span class="line"><span class="comment">//改为</span></span><br><span class="line"><span class="string">&quot;program&quot;</span>: <span class="string">&quot;<span class="subst">$&#123;workspaceFolder&#125;</span>\\<span class="subst">$&#123;workspaceRootFolderName&#125;</span>.exe&quot;</span>,</span><br></pre></td></tr></table></figure><ol start="3"><li>这样就变成VS了，会编译项目文件下所有C文件，集成到以项目名称命名的程序下。</li></ol></li></ol></li></ol><h3 id="vscode配置python虚拟环境"><a class="markdownIt-Anchor" href="#vscode配置python虚拟环境"></a> VSCode配置python虚拟环境</h3><p><a href="https://baijiahao.baidu.com/s?id=1767913548598914679&amp;wfr=spider&amp;for=pc">参考</a></p><p><strong>python打包</strong><br>使用<code>pyinstaller -F -c main.py</code>可以打包依赖库，而<code>pyinstaller -F main.py</code>就不行。<br>重点应该是那个<code>-c</code>.</p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Zotero 系列教程</title>
      <link href="/2023/11/07/%E5%AD%A6%E4%B9%A0/Zotero%20%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"/>
      <url>/2023/11/07/%E5%AD%A6%E4%B9%A0/Zotero%20%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="zotero与markdown"><a class="markdownIt-Anchor" href="#zotero与markdown"></a> Zotero与markdown</h2><ol><li>markdown中如何利用Zotero引用参考文献。<a href="https://blog.csdn.net/subtitle_/article/details/128995875">参考</a></li></ol><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 科研工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>土木工程专业课程设计</title>
      <link href="/2023/10/08/%E5%AD%A6%E4%B9%A0/%E5%9C%9F%E6%9C%A8%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/10/08/%E5%AD%A6%E4%B9%A0/%E5%9C%9F%E6%9C%A8%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="结构力学课程设计"><a class="markdownIt-Anchor" href="#结构力学课程设计"></a> 结构力学课程设计</h3><span id="more"></span><div class="pdf-container" data-target="结构力学课程设计.pdf" data-height="500px"></div><h3 id="混凝土楼盖课程设计"><a class="markdownIt-Anchor" href="#混凝土楼盖课程设计"></a> 混凝土楼盖课程设计</h3><div class="pdf-container" data-target="混凝土课程设计.pdf" data-height="500px"></div><h3 id="房屋结构课程设计"><a class="markdownIt-Anchor" href="#房屋结构课程设计"></a> 房屋结构课程设计</h3><div class="pdf-container" data-target="房屋结构课程设计.pdf" data-height="500px"></div><h3 id="基础工程课程设计"><a class="markdownIt-Anchor" href="#基础工程课程设计"></a> 基础工程课程设计</h3><div class="pdf-container" data-target="基础工程课程设计.pdf" data-height="500px"></div><h3 id="钢结构课程设计"><a class="markdownIt-Anchor" href="#钢结构课程设计"></a> 钢结构课程设计</h3><div class="pdf-container" data-target="钢结构课程设计.pdf" data-height="500px"></div><h3 id="土木工程施工课程设计"><a class="markdownIt-Anchor" href="#土木工程施工课程设计"></a> 土木工程施工课程设计</h3><div class="pdf-container" data-target="土木工程施工课程设计.pdf" data-height="500px"></div>]]></content>
      
      
      <categories>
          
          <category> 结构设计学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电子书籍查找教程</title>
      <link href="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/"/>
      <url>/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="电子书查找教程"><a class="markdownIt-Anchor" href="#电子书查找教程"></a> 电子书查找教程</h2><h3 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h3><p>使用<strong>科学上网</strong>，在google上搜索相关书籍，可能会找到相关电子版。如下图所示。</p><span id="more"></span><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/google搜索电子书.jpg" width="90%"></div><h3 id="方法二推荐"><a class="markdownIt-Anchor" href="#方法二推荐"></a> 方法二（推荐）</h3><ol><li><p>先在浏览器上安装<a href="https://greasyfork.org/zh-CN"><strong>油猴插件</strong></a>，</p><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/浏览器安装油猴插件.jpg" width="90%"></div><p>然后在<a href="https://greasyfork.org/zh-CN/">https://greasyfork.org/zh-CN/</a> 上安装网页脚本，这里推荐一个如下：<br><a href="https://greasyfork.org/zh-CN/scripts/457620-%E5%9B%BE%E4%B9%A6%E4%BA%92%E5%8A%A9-%E5%9B%BE%E4%B9%A6%E9%A6%86%E5%8F%82%E8%80%83%E5%92%A8%E8%AF%A2%E8%81%94%E7%9B%9F-%E8%AF%BB%E7%A7%80">图书互助-图书馆参考咨询联盟-读秀</a></p><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/油猴插件.jpg" width="90%"></div></li><li><p>然后打开<a href="http://www.ucdrs.superlib.net/"><strong>全国图书馆参考咨询联盟</strong></a>,(注册、登录过程省略)，输入自己一本想要的书，这时你会发现每本书下面都有一个<strong>图书互助</strong>，如下图所示。</p><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/全国图书馆参考联盟查书.jpg" width="90%"></div></li><li><p>点击<strong>图书互助</strong>，会跳转到另一个网站：<a href="http://tushu.163pdf.xyz/">互助助手</a>,如果这本书有电子资源，则会提示如下：</p><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/互助助手（能查到书）.jpg" width="70%"></div>如果显示如下画面，则这个网站（或者脚本）不能找到该资源。<div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/互助助手（未查到书）.jpg" width="70%"></div></li><li><p>如果能找到，则点击<strong>发起互助</strong>，可能会提示你登录（如果你没登录<strong>互助助手</strong>这个网站的话）。</p><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/互助助手（登录）.jpg" width="70%"></div><p>然后你可以在这个网站上购买积分，步骤如下：</p><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/卡密-1.jpg" width="70%"></div><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/卡密-2.jpg" width="70%"></div><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/卡密-34.jpg" width="70%"></div><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/卡密-5.jpg" width="70%"></div><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/卡密-6.jpg" width="70%"></div></li><li><p>登录之后，再次进入搜书界面，刷新一下，再点击<strong>图书互助</strong>，如下图所示：</p><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/刷新卡密.jpg" width="70%"></div></li><li><p>然后再次跳转到<strong>互助助手</strong>，再次<strong>发起互助</strong>，过半分钟左右，就有百度网盘链接了。</p><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/发起互助.jpg" width="70%"></div><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D/百度网盘链接.jpg" width="70%"></div></li></ol><p><strong>至此，你就能一元下载一本书的电子版啦！，比TB、PDD上商家实惠多了</strong>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>结构设计杂谈</title>
      <link href="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/"/>
      <url>/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<h3 id="内力组合相关疑惑"><a class="markdownIt-Anchor" href="#内力组合相关疑惑"></a> 内力组合相关疑惑</h3><p>以框架结构为例，<strong>抗震设计</strong>时，内力组合遵循一下原则：（电脑也是这么算的，具体可以参见<strong>广厦计算结果</strong>）<span id="more"></span><br>注意：下面γGE取1.2是老规范，新规范是1.3.</p><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/内力组合（一）.jpg" width="70%"></div><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/内力组合（二）.jpg" width="70%"></div><p>关键要义：<strong>在同一个组合下一直算（包括强柱弱梁等内力调整，要在同一个组合内调整），然后再在不同组合中取最不利的值</strong>。<br>广厦内力组合如下，验证了上面的想法。</p><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/广厦内力组合.jpg" width="90%"></div><h3 id="振型参与质量系数与振型有效质量系数的区别"><a class="markdownIt-Anchor" href="#振型参与质量系数与振型有效质量系数的区别"></a> 振型参与质量系数与振型有效质量系数的区别</h3><ol><li>振型参与质量（系数）是振型有效质量（系数）的推广。</li></ol><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/振型参与质量系数与振型有效质量系数.jpg" width="70%"></div><h3 id="焊接纵向-横向残余应力的理解"><a class="markdownIt-Anchor" href="#焊接纵向-横向残余应力的理解"></a> 焊接纵向、横向残余应力的理解</h3><p>1.焊接纵向残余应力<br>所谓<strong>纵向</strong>，就是<strong>应力方向与焊缝长度方向平行</strong>。如下图所示。</p><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/焊接纵向残余应力.jpg" width="70%"></div><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/焊接纵向残余应力-1.jpg" width="70%"></div><p>对于是<strong>拉应力还是压应力</strong>，应该这么理解：靠近焊缝的部分，在冷却时，受到两端已经冷却（或者说热影响不大）的区域限制，限制它<strong>收缩</strong>，故在其中产生了拉应力。由于板件<strong>未受外力</strong>，截面必然<strong>平衡</strong>，故两端的纵向残余应力为<strong>压应力</strong>。<br>2.焊接横向残余应力<br>所谓<strong>横向</strong>就是<strong>垂直于焊缝长度方向</strong>，例如两块板对接焊，当焊缝<strong>纵向收缩</strong>时，两块板件有向相反反向弯曲的趋势，造成焊缝中部<strong>两端受压，中间受拉</strong>。如下图所示。</p><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/焊接横向残余应力.jpg" width="70%"></div><h3 id="剪力墙按受力特性的分类及其受力特征"><a class="markdownIt-Anchor" href="#剪力墙按受力特性的分类及其受力特征"></a> 剪力墙按受力特性的分类及其受力特征</h3><ol><li><strong>整体墙</strong><br>定义：无洞口的剪力墙或剪力墙上开有一定数量的洞口，但洞口的面积不超过墙体面积的16%，且洞口至墙边的净距及洞口之间的净距大于洞孔长边尺寸时，可以忽略洞口对墙体的影响，这种墙体称为整体剪力墙。<br>受力特征：整体剪力墙的受力状态如同竖向悬臂梁，截面变形后仍符合平面假定，<strong>因而截面应力可按材料力学公式计算</strong>，变形属弯曲型。</li><li><strong>整体小开口墙</strong><br>定义：当剪力墙上所开洞口面积稍大且超过墙体面积的16%时，在水平荷载作用下，这类剪力墙截面上的正应力分布略偏离了直线分布的规律，变成了相当于在整体墙弯曲时的直线分布应力之上叠加了墙肢局部弯曲应力，当墙肢中的局部弯矩不超过墙体整体弯矩的15%时，其截面变形仍接近于整体截面剪力墙，这种剪力墙称之为小开口整体剪力墙。<br>受力特征：<strong>对于小开口剪力墙，其截面变形大体上仍符合平面假定，正应力大体上呈直线分布。为计算方便，力和变形仍按材料力学计算，然后适当修正。</strong>（一般<strong>内力计算</strong>是：将总力矩的85%按材料力学的方法计算墙肢弯矩及轴力，将总力矩的15%按墙肢的刚度进行分配。<strong>位移的计算</strong>：按照整体墙计算，不过考虑到洞口削弱墙体刚度，最终结果要放大20%）</li><li><strong>联肢墙</strong><br>定义：当剪力墙沿竖向开有一列或多列较大的洞口时，由于洞口较大，剪力墙截面的整体性已被破坏，剪力墙的截面变形已不再符合平截面假设。这时剪力墙成为由一系列连梁约束的墙肢所组成的联肢墙。<br>受力特征：洞口开得比较大，截面的整体性已经破坏，<strong>横截面上正应力的分布远不是遵循沿一根直线的规律。<strong>但墙肢的线刚度比同列两孔间所形成的连梁的线刚度大得多，每根连梁中部有反弯点，各墙肢单独弯曲作用较为显著，但仅在个别或少数层墙肢出现反弯点。<strong>其变形曲线与整体小开口墙相近，仍以弯曲变形为主</strong>，内力计算宜采用连续化方法，例如</strong>连续连杆法</strong>。<blockquote><p>连续连杆法：<br><strong>基本假定</strong>：<br>1. 连梁反弯点位于跨中，连梁的作用可以用沿高度 均匀分布的连续弹性薄片代替。<br>2. 各墙肢的刚度相差不过分悬殊，因而变形曲线相似。<br>3. 连梁和墙肢考虑弯曲和剪切变形，墙肢还应考虑轴向变形的影响。<br>4. 各墙肢、连梁截面尺寸、材料强度及层高沿剪力墙全高相同。<br><strong>基本原理</strong>：运用力法原理，将连梁中点切开，去掉多余约束，建立静定体系。切开后连杆剪力是多余未知力，是一个连续函数。由切开处的变形协调条件建立连杆剪力的微分方程，求解微分方程即得连杆剪力 。将层高范围内的各点剪力积分还原成一根连梁的剪力。各层连梁中点剪力求出后，所有墙肢及连梁内力都可相继求出。</p></blockquote></li><li><strong>壁式框架</strong><br>定义：当剪力墙的洞口尺寸较大，墙肢宽度较小，连梁的线刚度接近于墙肢的线刚度时，剪力墙的受力性能已接近于框架，这种剪力墙称为壁式框架。<br>受力特征：洞口开得比联肢剪力墙更宽，墙肢宽度较小，墙肢与连梁刚度接近时，墙肢明显出现局部弯矩，在许多楼层有反弯点。剪力墙的内力分布接近框架。壁式框架实质是介于剪力墙和框架之间的一种过渡形式，它的变形已很接近剪切型。只不过壁柱和壁梁都较宽，因而在梁柱交接区形成不产生变形的刚域。</li></ol><h3 id="框架剪力墙结构内力计算"><a class="markdownIt-Anchor" href="#框架剪力墙结构内力计算"></a> 框架剪力墙结构内力计算</h3><div class="pdf-container" data-target="框架剪力墙结构内力计算.pdf" data-height="500px"></div><h3 id="双向板计算"><a class="markdownIt-Anchor" href="#双向板计算"></a> 双向板计算</h3><p>对于双向板的设计，有<strong>弹性设计</strong>和<strong>塑性设计</strong>两种。对于弹性设计，是通过查表得出弯矩设计值，书上也容易理解。对于塑性设计，书上采用了<strong>塑性铰线法</strong>，通过一系列推到，得到荷载P作用时，板的弯矩（书上表述为<strong>承载力</strong>，尚有不妥，应该为<strong>内力</strong>更好），然后配筋设计了。</p><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/双向板塑性设计.jpg" width="90%"></div><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/双向板塑性设计计算公式.jpg" width="80%"></div><p>从中也可以发现，所谓弹性设计、塑性设计，归纳起来就是<strong>以何种状态的抗力去抵抗该状态下的效应就是何种设计。</strong></p><h4 id="何为单向板与双向板"><a class="markdownIt-Anchor" href="#何为单向板与双向板"></a> 何为单向板与双向板？</h4><p>在学习《混凝土结构基本原理》之初，对于单向板，我们是按照长边/短边大于2（具体分为大于等于3和介于2-3之间）的原则来判断的。久而久之容易形成刻板印象，只通过边长比值来判断，这是不可取的。（见《混凝土》下册P30）<br>而实际上单向板和双向板定义：只在一个方向弯曲或主要在一个方向弯曲的板称为单向板；在两个方向弯曲且不能忽略任一方向弯曲的板称为双向板。</p><h3 id="应力应变-内力与位移之间关系"><a class="markdownIt-Anchor" href="#应力应变-内力与位移之间关系"></a> 应力应变、内力与位移之间关系</h3><p>应力与应变之间关系：<br>有应力不一定有应变（这个命题本身不是很严谨）比如三个方向应力取值得当可以使得某一方向无应变。<br>有应变不一定有应力，比如静定结构由于温度差异产生的应变。<br>内力和位移之间联系：<br>有内力不一定有位移。比如超静定结构中，由于温度变形受到限制而产生内力，但无位移。<br>有位移不一定有内力。比如静定结构支座位移并不产生内力。<br>关于<strong>位移和变形</strong>的区别，可以参考如下：</p><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%82%E8%B0%88/位移、变形的区别.png" width="90%"></div>]]></content>
      
      
      <categories>
          
          <category> 结构设计学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
      <url>/2023/10/05/%E5%AD%A6%E4%B9%A0/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h2><h3 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h3><ol><li>安装<a href="https://nodejs.org/en">Nodejs</a>,这里选择<code>LTS</code>版本，安装好后，运行如下命令(建议使用以管理员方式运行,例如将git bash设置为以管理员方式打开，我是选择始终以管理方式运行git bash)，检查nodejs安装是否成功。<a href="https://git-scm.com/"><strong>Git下载</strong></a>,建议装在系统盘(例如C盘)。<span id="more"></span><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查nodejs是否安装成功</span></span><br><span class="line"><span class="keyword">node</span> <span class="title">-v</span></span><br><span class="line">npm -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看npm下载的全局保存目录(prefix)和缓存位置(cache)</span></span><br><span class="line"><span class="comment"># 如果在C盘，可以换到D盘某个位置，例如就在Nodejs安装路径下新建`node_global`和`node_cache`两个文件夹。</span></span><br><span class="line"><span class="comment"># 然后更改`Nodejs安装路径\node_modules\npm`下的npmrc和.npmrc文件，加上上述两个文件夹的路径。</span></span><br><span class="line">npm config ls  </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>将Nodejs中的全局保存目录（保存下载的库）和<code>Nodejs安装路径\node_modules\npm</code>放到系统变量中的Path下，如下图所示。</p><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/nodejs添加环境变量.jpg" width="70%"></div><blockquote><p>其中全局保存目录是为了后面<code>hexo</code>命令能顺利运行，而<code>...\npm</code>文件夹则是为了npm能顺利运行。</p></blockquote></li><li>然后在博客文件夹（必须是新文件夹）(这里以<code>D:\Blog</code>举例),git bash,运行如下命令：<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-<span class="keyword">cli</span> <span class="meta">#(下载到全局保存目录)</span></span><br><span class="line"></span><br><span class="line">hexo init <span class="meta"># 博客初始化</span></span><br><span class="line"></span><br><span class="line">npm install hexo-<span class="keyword">cli</span>  <span class="meta">#下载hexo到`D:\Blog\node_modules`</span></span><br><span class="line"></span><br><span class="line">hexo -v <span class="meta"># 若成功显示版本，则表示hexo安装成功了。</span></span><br><span class="line"></span><br><span class="line">hexo g  </span><br><span class="line"></span><br><span class="line">hexo s  <span class="meta"># 然后再本地打开即可。</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 这样博客就初步搭建完成了。</span></span><br></pre></td></tr></table></figure></li><li>可以运行<code>hexo new  xxx.md</code>来生成文章，然后运行<code>hexo g</code>，等待部署到github上。</li><li>参考：<a href="https://blog.csdn.net/m0_48121128/article/details/132380427"><strong>完成hexo到GitHub的部署</strong></a>，这里要注意，在博客目录下config.yaml修改时（如下）：<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">   type:</span> git</span><br><span class="line"><span class="symbol">   repo:</span> git@github.com:Yourname/Yourname.github.io.git   <span class="meta"># 这里不要用https: 链接，否则后面部署时傻里傻气的。</span></span><br><span class="line"><span class="symbol">   branch:</span> main  <span class="meta">#这里分支要选择好，main是默认的，可以新建分支(比如source)，但要对应github-pages那里生成的分支，如下图所示。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/github%20pages生成选择分支.jpg" width="70%"></div></li><li>再运行<code>npm install hexo-deployer-git --save</code>（否则<code>hexo d</code>无效，无法完成部署）。</li></ol><h3 id="搭建过程疑问"><a href="#搭建过程疑问" class="headerlink" title="搭建过程疑问"></a>搭建过程疑问</h3><ol><li>最开始搭建一个最简单的网站主要参考一下几条博客。<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>blog.csdn.net<span class="regexp">/sinat_37781304/</span>article<span class="regexp">/details/</span><span class="number">82729029</span></span><br></pre></td></tr></table></figure></li><li>hexo 如何新建一篇文章。<!--more--><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost blog]# hexo <span class="keyword">new</span> <span class="string">&quot;如何在hexo上创建一篇文章&quot;</span></span><br><span class="line">...</span><br><span class="line">INFO  Created: <span class="regexp">/blog/</span><span class="keyword">source</span><span class="regexp">/_posts/</span>如何在hexo上创建一篇文章.md</span><br></pre></td></tr></table></figure>这个缺点是他只能在<code>...source/_posts</code>下生成，没法完成自己的分类，还是推荐在<code>VSCode</code>中创建新文章。</li><li><p>hexo 显示无法连接到 <code>github</code>.</p><blockquote><p>fatal: unable to access ‘<a href="https://github.com/Hushuangjun/Hushuangjun.github.io.git">https://github.com/Hushuangjun/Hushuangjun.github.io.git</a></p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>blog.csdn.net<span class="regexp">/weixin_46087812/</span>article<span class="regexp">/details/</span><span class="number">124575202</span></span><br></pre></td></tr></table></figure><p>如果在搭建过程中，采用<code>repo: git@github.com:Yourname/Yourname.github.io.git</code>,则不会报这个错。</p></li><li>markdown中插入本地图片不显示<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>www.cnblogs.com<span class="regexp">/koo070/</span>p/<span class="number">16548228</span>.html</span><br></pre></td></tr></table></figure></li><li>怎么实现图片等比例缩放，或者指定高度，并且居中、左、右？<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>zhuanlan.zhihu.com<span class="regexp">/p/</span><span class="number">139007418</span></span><br></pre></td></tr></table></figure></li><li>为啥hexo-pdf按操作弄完之后，点进去直接下载却不显示pdf？<blockquote><p>因为我们<strong>idm</strong>插件接管了那个命令，<strong>只要把浏览器的idm插件关闭即可</strong>。</p></blockquote></li><li><p>为啥每次<code>hexo d</code>后，在<code>settings-pages</code>那里都要重新配置<code>custom domain</code>?</p><blockquote><p>为避免这个麻烦，可以在博客目录下<code>source</code>文件夹下新建<code>CNAME</code>,内容为需要绑定的域名(我的为<code>husj0711.top</code>).<br>参考<a href="https://blog.csdn.net/weixin_49175501/article/details/128705141">解决方案</a></p></blockquote></li><li><p>为啥博客在本地(localhost:4000)查看可以，网络打开排版很乱。<br><code>Shift + F5</code>强制刷新页面即可。</p></li><li><p>在hexo-Next如何显示latex公式？<br> 多翻阅<a href="https://theme-next.js.org/docs/third-party-services/math-equations.html">官方文档</a>,里面有详细的步骤，这里选用<strong>katex</strong>，大致步骤简述如下：</p><ol><li>卸载hexo的插件<code>hexo-math</code>和<code>hexo-katex</code>，否则会与Next主题自带的渲染插件冲突；<blockquote><p>npm uninstall hexo-math<br>npm uninstall hexo-katex</p></blockquote></li><li>在主题配置文件中将Katex设置为渲染引擎；<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">katex:</span></span><br><span class="line">     <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li>卸载原始渲染引擎<code>hexo-renderer-marked</code>，下载新的渲染引擎<code>npm i hexo-renderer-markdown-it-plus</code>或者<code>npm i hexo-renderer-markdown-it</code>.<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">npm</span> un hexo-renderer-marked</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">npm</span> i hexo-renderer-markdown-<span class="literal">it</span>-plus</span><br><span class="line"><span class="keyword">or</span></span><br><span class="line">$ <span class="built_in">npm</span> i hexo-renderer-markdown-<span class="literal">it</span></span><br></pre></td></tr></table></figure></li></ol></li><li>遇到katex渲染的公式不显示怎么办？<br>首先，在next主题配置文件<code>_config.yml</code>把katex的<code>enable</code>开关给关掉，然后再运行<code>hexo clean</code>,随后再把katex的<code>enable</code>打开（改成true），最后运行<code>hexo g &amp;&amp; hexo d</code>即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>力学基础和专业基础(持续更新)</title>
      <link href="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/10/05/%E5%AD%A6%E4%B9%A0/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="材料力学"><a class="markdownIt-Anchor" href="#材料力学"></a> 材料力学</h2><span id="more"></span><ol><li><p>最近学了拉压、扭的部分，大致思路都是<strong>强度-刚度-应变能</strong>，公式也很类似。下面分享几个比较有意思的点：<br>第一个是<strong>小变形放大图</strong>，常用来解决超静定问题，依靠<strong>平衡方程</strong>和<strong>变形协调方程</strong>，再加上本构方程。这里的<strong>变形协调</strong>其实就是后面<strong>力法方程的本质</strong>，可以说是埋下伏笔了。</p></li><li><p>第二个是<strong>功互等定理</strong>和<strong>位移互等定理</strong>，在材料力学中只是当作附加部分讲了讲，并没有涉及其本质，具体推导可以参见 <strong>《结构力学》（龙驭球）第五章最后一节</strong>，用虚功原理予以解释，此外，那里还介绍了两个互等定理。注意：上述四个互等定理只适用于<strong>线性变形体系</strong>。</p></li><li><p><strong>剪应力互等定理</strong>新的理解<br>详细可以参考一下这篇文章。感觉与以前理解不同的地方在于：取出来的单元体实际上六个面均有力，每个面有两个方向的切应力和一个正应力，相对的面上应力相等。（他给出的解释是单元体足够小，可以看作一个点，故相对的两个面力相等）</p> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>www.zhihu.com<span class="regexp">/question/</span><span class="number">21070058</span></span><br></pre></td></tr></table></figure></li><li><p>非对称纯弯曲梁的正应力（《材料力学》下册1-1节）<br>推导得到了<strong>广义弯曲正应力</strong>，有一个印象即可。对于<strong>非对称弯曲</strong>，应该是指梁不具有对称平面，或者梁具有对称平面，但外力不作用在该平面内，梁将发生非对称弯曲。</p></li><li><p>开口薄壁截面梁的剪应力流和弯曲中心<br><strong>截面剪应力流的方向确定</strong>：(简单的根据：与剪力平行的截面上剪应力流与剪力平行，例如矩形截面，工字形截面的腹板等。)</p><ol><li>根据截面弯矩和中性轴确定拉压应力；(方便下一步由正应力合成轴力)</li><li>切开构件，取隔离体，根据隔离体轴力平衡，非自由面取切应力(一般只有3个非自由面，其中有两个是前后轴力方向，另一个面取剪应力来平衡)，然后再根据剪应力互等定理确定前后两个非自由面上剪应力方向。</li></ol><div class="pdf-container" data-target="弯曲中心.pdf" data-height="500px"></div><p>而弯曲中心的确定方法见《材料力学合并文档》P252.核心就是<strong>截面上剪应力合成到某点，只有力而无力偶，该点即为弯曲中心</strong>。<br>重点是<strong>弯曲中心（剪切中心）的作用</strong>：非对称截面梁发生平面弯曲的条件：<strong>外力必须作用在通过弯曲中心且平行于形心主惯性平面（或与之重合）的平面内。</strong></p></li></ol><h2 id="结构力学"><a class="markdownIt-Anchor" href="#结构力学"></a> 结构力学</h2><h3 id="单自由度结构自由振动自振频率的求解"><a class="markdownIt-Anchor" href="#单自由度结构自由振动自振频率的求解"></a> 单自由度结构自由振动自振频率的求解</h3><p>今天复习了结构动力学基础中一个重要问题——单自由度结构体系自由振动自振频率的求解。困扰了将近一年的问题今天终于搞定了。顺便复习了<strong>科氏加速度</strong>等几个概念，具体参见《理论力学》P190.</p><div class="pdf-container" data-target="单自由度结构体系自振频率求解.pdf" data-height="500px"></div><h3 id="虚功原理-虚力原理与虚位移原理辨析"><a class="markdownIt-Anchor" href="#虚功原理-虚力原理与虚位移原理辨析"></a> 虚功原理、虚力原理与虚位移原理辨析</h3><div class="pdf-container" data-target="虚功原理、虚力原理与虚位移原理.pdf" data-height="500px"></div><p>根据上述资料，可知虚功原理表述为：<br>如果<strong>力系满足平衡方程，变形状态满足协调方程</strong>，则虚功方程（下式）成立。</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>∑</mo><msub><mi>F</mi><mi>P</mi></msub><mi mathvariant="normal">Δ</mi><mo>+</mo><mo>∑</mo><msub><mi>F</mi><mrow><mi>R</mi><mi>K</mi></mrow></msub><msub><mi>C</mi><mi>K</mi></msub><mo>=</mo><mo>∑</mo><msubsup><mo>∫</mo><mi>A</mi><mi>B</mi></msubsup><mo stretchy="false">(</mo><mi>M</mi><mi>k</mi><mo>+</mo><msub><mi>F</mi><mi>N</mi></msub><mi>ε</mi><mo>+</mo><msub><mi>F</mi><mi>Q</mi></msub><msub><mi>γ</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mi>d</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\sum F _ { P } \Delta + \sum F _ { R K } C _ { K } = \sum \int _ { A } ^ { B } ( Mk+ F _ { N } \varepsilon + F _ { Q } \gamma _ { 0 } ) d s </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">Δ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.5031810000000005em;vertical-align:-0.9119499999999999em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5912310000000005em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span style="top:-3.812900000000001em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">ε</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">Q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span></span></span></span></span></p><p><strong>然后，单独一个虚功方程只是必要条件，而不是充分条件。</strong><br>由此引出一个想法：能否将虚功原理及其虚功方程(上式)加以改造，使改造后的“虚功型方程”（指：用虚功形式表示的方程）成为变形协调方程或力系平衡方程的充分必要条件呢？于是，就产生了下列两个“虚功型原理”一虚力原理和虚位移原理。<br><strong>虚力原理</strong>：<br><strong>在虚设力系满足平衡方程且具有任意性的前提下</strong>，如果虚力方程（下图）成立，则待检查的变形状态必满足变形协调方程。反之，在上述前提下，如果已知该变形状态满足变形协调方程，则虚力方程必成立。综合起来，在上述前提下，虚力方程是变形协调方程的充分必要条件。</p><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/虚力方程.jpg" width="70%"></div><p><strong>虚位移原理</strong>：<br>在虚设变形状态满足变形协调方程并具有任意性的前提下，如果虚位移方程(下式)成立，则待检查的力系必满足平衡方程。反之，在上述前提下，如果已知该力系满足平衡方程，则虚位移方程必成立。综合起来，在上述前提下，虚位移方程是力系平衡方程的充分必要条件。</p><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/虚位移方程.jpg" width="70%"></div><h3 id="结构对称性探究"><a class="markdownIt-Anchor" href="#结构对称性探究"></a> 结构对称性探究</h3><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/结构力学对称性探究-1.JPG" width="70%"></div><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/结构力学对称性探究-2.JPG" width="70%"></div><p>正是由于上述结论，可将奇/偶跨对称结构简化，值得注意的是，**对称轴处的荷载要减半，当然最终结果加和时，对称轴处相当于加了两次，合理的。**可参考下面这篇文章：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文章一：https:<span class="regexp">//</span>zhuanlan.zhihu.com<span class="regexp">/p/</span><span class="number">576399081</span></span><br><span class="line">文章二：https:<span class="regexp">//</span>zhuanlan.zhihu.com<span class="regexp">/p/</span><span class="number">147244195</span></span><br></pre></td></tr></table></figure><h4 id="对称边界与反对称边界位移条件"><a class="markdownIt-Anchor" href="#对称边界与反对称边界位移条件"></a> 对称边界与反对称边界位移条件</h4><p>最近学习了<strong>水哥ansys初级教程</strong>，其中谈到<strong>对称边界和反对称边界位移条件时</strong>时，有：</p><ol><li>受对称载荷作用则对称面上的位移条件为<ol><li>垂直于对称面的移动位移分量为零。</li><li>绕平行于对称面的两相互垂直的轴的转动位移分量均为零。</li></ol></li><li>受反对称载荷作用则对称面上的位移条件为<ol><li>平行于对称面的移动位移分量为零；</li><li>绕方向矢量垂直于对称面的轴的转动位移分量为零。</li></ol></li></ol><h3 id="结构矩阵分析-平衡-几何互伴定理"><a class="markdownIt-Anchor" href="#结构矩阵分析-平衡-几何互伴定理"></a> 结构矩阵分析-“平衡-几何”互伴定理</h3><p>定理证明：</p><ul><li>龙驭球《结构力学》下册 第14章</li></ul><p>定理的运用，以老师留的习题为例：</p><div class="pdf-container" data-target="结构矩阵分析-平衡几何定理.pdf" data-height="500px"></div><h2 id="土力学"><a class="markdownIt-Anchor" href="#土力学"></a> 土力学</h2><p>待更新！！！</p><h2 id="混凝土结构基本原理"><a class="markdownIt-Anchor" href="#混凝土结构基本原理"></a> 混凝土结构基本原理</h2><h3 id="钢筋混凝土受扭构件承载力公式推导的两种方法"><a class="markdownIt-Anchor" href="#钢筋混凝土受扭构件承载力公式推导的两种方法"></a> 钢筋混凝土受扭构件承载力公式推导的两种方法</h3><p>此文章写于大三下学期，目前来看，这两种方法的本质相同，第一种根据q相同求得，第二种根据Tu相同求得，但又有</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>T</mi><mi>u</mi></msub><mo>=</mo><mn>2</mn><mi>q</mi><msub><mi>A</mi><mrow><mi>c</mi><mi>o</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{u} = 2qA_{cor}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>故其本质相同。</p><div class="pdf-container" data-target="钢筋混凝土受扭构件承载力.pdf" data-height="500px"></div><h2 id="钢结构基本原理"><a class="markdownIt-Anchor" href="#钢结构基本原理"></a> 钢结构基本原理</h2><h3 id="稳定性"><a class="markdownIt-Anchor" href="#稳定性"></a> 稳定性</h3><h4 id="规范上对于轴心受压-受弯及压弯构件的宽厚比限值是从何得来的"><a class="markdownIt-Anchor" href="#规范上对于轴心受压-受弯及压弯构件的宽厚比限值是从何得来的"></a> 规范上对于轴心受压、受弯及压弯构件的宽厚比限值是从何得来的？</h4><p>宽厚比限值的根本目的是为了防止局部失稳先于整体失稳。由此，规范采用等稳定性原则，即板件屈曲应力不小于构件屈曲应力。</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>σ</mi><mrow><mi>c</mi><mi>r</mi><mi>x</mi></mrow></msub><mo>≥</mo><msub><mi>σ</mi><mrow><mi>c</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\sigma_{crx}\geq \sigma _{cr}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>同时，根据<strong>以何种状态下（例如弹性）抗力抵抗该种状态下效应即为该种状态设计</strong>，故当板件弹性屈曲应力不小于构件弹性屈曲应力，为<strong>弹性设计</strong>。</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><msub><mi>b</mi><mn>1</mn></msub><mi>t</mi></mfrac><mo>≤</mo><mn>15</mn><msub><mi>ε</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\frac{b_{1}}{t}\leq 15 \varepsilon _{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord"><span class="mord mathnormal">ε</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>这些天(2023-10-17)恰好在学习冷弯薄壁型钢的设计，这里举例如下：</p><div align="center"><img src="/2023/10/05/%E5%AD%A6%E4%B9%A0/%E5%8A%9B%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%92%8C%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/冷弯薄壁型钢整体屈曲与局部屈曲关系.jpg" width="70%"></div><h2 id="土木工程施工"><a class="markdownIt-Anchor" href="#土木工程施工"></a> 土木工程施工</h2><h3 id="土方工程"><a class="markdownIt-Anchor" href="#土方工程"></a> 土方工程</h3><h4 id="基坑支护"><a class="markdownIt-Anchor" href="#基坑支护"></a> 基坑支护</h4><p>基坑支护包括一般基坑支护和深基坑支护。<br>深基坑支护方法有：</p><ol><li><strong>水泥土挡墙式支护结构</strong>：采用深层搅拌机就地将土和输入的水泥浆强行搅拌，形成连续搭接的水泥土柱状加固体挡墙。</li><li><strong>排桩与板墙式支护结构</strong>：开挖前在基坑周围设置砼灌注桩或钢板桩，桩的排列有间隔式、双排式和连续式，桩顶设置砼连系梁或锚桩、拉杆。</li><li><strong>土钉墙支护</strong>：在天然土体通过钻孔、插筋、注浆来设置土钉(亦称砂浆锚杆)并与喷射砼面板相结合，形成类似重力挡墙的土钉墙，以抵抗墙后的土压力，保持开挖面的稳定。</li><li><strong>土层锚杆支护结构</strong>：在深基础立壁上钻孔，并达到一定深度，然后在孔内放入钢筋等材料，灌入泥浆或化学浆液，使其与土层结合成为抗拉（拔）力强的锚杆，将立壁土体侧压力传至稳定土层。<blockquote><p>在实际工程中，其实上述某些方法可组合使用，例如挡土灌注桩（排桩）+土层锚杆等。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 结构设计学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 材料力学 </tag>
            
            <tag> 结构力学 </tag>
            
            <tag> 土力学 </tag>
            
            <tag> 混凝土结构基本原理 </tag>
            
            <tag> 钢结构基本原理 </tag>
            
            <tag> 土木工程施工 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学生活</title>
      <link href="/2023/05/05/%E7%94%9F%E6%B4%BB/%E6%9C%AC%E7%A7%91%E7%94%9F%E6%B4%BB/"/>
      <url>/2023/05/05/%E7%94%9F%E6%B4%BB/%E6%9C%AC%E7%A7%91%E7%94%9F%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="五一假期"><a class="markdownIt-Anchor" href="#五一假期"></a> 五一假期</h2><p>这几天都在学校学习，认真看了高层建筑这本书，感觉讲的比较浅显，如果不看具体例子不容易理解。<span id="more"></span></p><p>5.1号还去网球场打了会网球，感觉有一点点进步，继续加油。</p><p>高中学姐请我出来吃饭，转眼间三年快过去了，真快呀，还记得刚来青岛时学长学姐们欢迎我们的时候，有时候真挺不舍的，但天下没有不散的筵席，今日的分别时为了他日更好的相见，加油加油！</p><p>祝学姐毕业快乐！工作顺利！<br>接下来我也要忙着复习和准备着保研啦！</p><h2 id="钢结构设计后休闲时光"><a class="markdownIt-Anchor" href="#钢结构设计后休闲时光"></a> 钢结构设计后休闲时光</h2><p>下面是两周完成的<strong>钢结构设计</strong>，还可以吧！</p><div class="pdf-container" data-target="钢结构课程设计.pdf" data-height="500px"></div><p>搞完设计感觉自己有点懒惰，夏令营那些东西还没弄完呢，加上自己又碰上了毛囊炎，真该死呀！振作起来振作起来！！！<br>最近睡得也比较晚，精神状态极差，需要尽快调整过来。今晚争取把个人自述科研经历部分写完。</p>]]></content>
      
      
      <categories>
          
          <category> 日常记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
